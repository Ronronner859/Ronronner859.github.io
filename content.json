{"meta":{"title":"大白话说前端，多读源码多实践，勤于思考善领悟","subtitle":"","description":"我相信一万小时定律","author":"er dong yi","url":"http://example.com"},"pages":[],"posts":[{"title":"博客维护中..... 请跳转到CSDN","slug":"My-Gallery","date":"2024-07-20T14:00:41.000Z","updated":"2024-07-21T15:15:24.503Z","comments":true,"path":"2024/07/20/My-Gallery/","permalink":"http://example.com/2024/07/20/My-Gallery/","excerpt":"","text":"[CSDN]: “https://blog.csdn.net/qq_51714990?spm=1000.2115.3001.5343“","categories":[],"tags":[],"keywords":[]},{"title":"JS_函数中this的指向多情况分析","slug":"JS01_函数中this的指向多情况分析","date":"2024-07-20T10:58:13.713Z","updated":"2024-07-21T04:35:26.443Z","comments":true,"path":"2024/07/20/JS01_函数中this的指向多情况分析/","permalink":"http://example.com/2024/07/20/JS01_%E5%87%BD%E6%95%B0%E4%B8%ADthis%E7%9A%84%E6%8C%87%E5%90%91%E5%A4%9A%E6%83%85%E5%86%B5%E5%88%86%E6%9E%90/","excerpt":"","text":"JS_函数中的this的指向多情况分析1.默认绑定默认绑定this都是指向的window全局对象 JS中只要定义了一个方法，那么该方法就会有this指向，然而在不同的情况this的指向也会有所不同 情况一：函数直接调用 情况二：通过对象调用 情况三：箭头函数调用 12345678910111213141516171819202122// 1.直接调用function foo() &#123; console.log(&#x27;this绑定规则一之默认绑定&#x27;); console.log(this)&#125;foo()// 2.函数定义在对象之后，但是独立调用var obj = &#123; name: &quot;John&quot;, bar:function ()&#123; console.log(&#x27;bar&#x27;,this) &#125;&#125;var bax = obj.barbax()// 3.高阶函数function test(fn)&#123; fn()&#125;test(obj.bar); 上面两种方式的调用this都是默认绑定，指向的window全局对象 补充：若是在严格模式”use strict”下，独立调用的函数的this指向是指向undefined 2.隐式绑定隐式绑定this指向的是某个对象发起的函数调用，指向这个对象本身 12345678// 也就是它的调用位置中，是通过某个对象发起的函数调用function foo() &#123; console.log(this)&#125;var x = &#123; bar:foo&#125;x.bar() this指向的是x这个对象本身。 3.new关键字使用new关键词时，会创建一个新的空对象，this指向这个空对象【简单解释】 12345678910111213function foo() &#123; console.log(this) this.name = &#x27;hello world&#x27;&#125; new foo()// foo()/*1.创建一个空对象2.将this指向这个空对象3.指向函数体中的代码4.没有显示返回的非空对象时，默认返回这个对象 */ 控制台打印结果为：foo {} 4.显示绑定apply、call、bind4.1 call函数可以执行call函数，强制this指向某一个对象，可以明确的告诉this绑定什么，直接了当 123456789101112var obj = &#123; name: &quot;John&quot;,&#125;function add() &#123; console.log(this)&#125;// obj.add = add// obj.add()// 执行函数，并且强制this就是obj对象 自己显示的明确告诉他绑定什么//执行函数，并且函数中的this指向obj对象add.call(obj)add.call(412) 4.2 apply函数apply函数主要与call的区别是传入的参数格式不同，都可以明白告诉this绑定什么 123456789101112131415161718192021/* 调用一起函数，同时绑定一个this */function foo(name,age,height)&#123; console.log(this) console.log(name,age,height)&#125;foo(&#x27;kobe&#x27;, 12, 1.98)/* 第一个参数：绑定this 第二个参数：传入额外的参数，以数组的形式 */foo.apply(&#x27;hello world&#x27;, [&#x27;kobe&#x27;, 12, 1.98]);/* 第一个参数：绑定this 参数列表：后续的参数是以多参数的一个形式的 */foo.call(&#x27;call&#x27;, &quot;zhangsan&quot;, 213, 2.07);// call 和 apply 第二个参数的传入的格式不一样 4.3 bind函数bind() 被调用时，这个新函数的 this 被指定为 bind() 的第一个参数，而其余参数将作为新函数的参数，供调用时进行使用 官方：Function.prototype.bind() Function 实例的 bind() 方法创建一个新函数，当调用该新函数时，它会调用原始函数并将其 this 关键字设置为给定的值，同时，还可以传入一系列指定的参数，这些参数会插入到调用新函数时传入的参数的前面。 1234567891011function foo()&#123; console.log(this)&#125;var obj = &#123;name:&#x27;john&#x27;&#125;// 需求:调用foo时，总是绑定到obj对象身上(不希望obj对象身上有函数)// 在 bind() 被调用时，这个新函数的 this 被指定为 bind() 的第一个参数，而其余参数将作为新函数的参数，供调用时进行使用 var bar = foo.bind(obj);bar()console.log(foo) 经典案例： 12345678910111213141516171819202122const module = &#123; x: 42, getX: function () &#123; console.log(&#x27;111&#x27;) return this.x; &#125;,&#125;;/** * unboundGetX 没有绑定到 module，所以 this 指向全局对象，导致返回 undefined。 * boundGetX 被绑定到 module，所以 this 指向 module，返回 42。 * */const unboundGetX = module.getX;// 全局下调用unboundGetX是this会指向全局对象windows nodejs中指向global 全局中无x，输出undefinedconsole.log(unboundGetX()); // The function gets invoked at the global scope// Expected output: undefined// bind 方法创建了一个新的函数，该函数的 this 永远指向 module。const boundGetX = unboundGetX.bind(module);console.log(boundGetX());// Expected output: 42 4.4 call()、apply()、bind()的区别及用法简单用法：都是用来改变this的指向 call、apply的一个区别： 相同点：都是调用一个对象的一个方法，用另一个对象替换当前对象（功能相同） 不同点：参数格式不同 call()的第一个参数是this要指向的对象，后面传入的是参数列表，参数可以是任意类型，当第一个参数为null、undefined的时候，默认指向window；apply()：第一个参数是this要指向的对象，第二个参数是数组[]call、bind的一个区别： 相同点: 都是用来改变this的指向 不同点：call改变this的指向后会再执行函数，bind改变this的指向后不会再执行函数，返回一个绑定新this的函数【React有用到】 用法：call函数 用来判断数据类型！ 延伸–判断数据类型的方式有哪几种？ 在判断数据类形式使用typeof，一般不是太准确的，我们可以使用Object.prototype.toString.call()方法来判断一个数据的数据类型 利用call()翻转字符串 用法：apply函数 进行求和计算 4.5 扩展：函数绑定的新姿势 ——ES7 bind 运算符（::） ES7 bind 运算符是一种新的绑定语法，它使用两个冒号 (::) 表示，通常被称为 “双冒号运算符” 或者 “作用域解析运算符”。它的作用是将一个函数绑定到一个特定的上下文中。bind 运算符始终将左边的表达式作为函数的上下文（即 this），右边的表达式作为函数名，同时还会将左边表达式中的属性和方法转移到右边表达式中。 6.this绑定规则优先级7.this绑定之外的规则8.箭头函数的写法arrow function9.箭头函数的简写arrow10.箭头函数实现所有偶数平方的和11.箭头函数中的this使用12.箭头函数中this的应用【模拟网络请求】","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/categories/JavaScript/"}],"tags":[],"keywords":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/categories/JavaScript/"}]},{"title":"一文知TypeScript的核心","slug":"颠覆认知的『TypeScript』【TS深度学习】","date":"2024-03-20T14:00:41.000Z","updated":"2024-07-21T04:36:07.563Z","comments":true,"path":"2024/03/20/颠覆认知的『TypeScript』【TS深度学习】/","permalink":"http://example.com/2024/03/20/%E9%A2%A0%E8%A6%86%E8%AE%A4%E7%9F%A5%E7%9A%84%E3%80%8ETypeScript%E3%80%8F%E3%80%90TS%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%91/","excerpt":"","text":"TypeSript【官网】【READBOOK】https://www.bookstack.cn/read/wangdoc-typescript-tutorial/docs-d.ts.md ts是js的一个超集，解决js类型支持js: 动态类型ts:静态类型 代码执行的顺序是先编译在执行 发现错误更早 1.为什么要添加类型支持？ 2.优势有什么？ 3.全局安装npm i -g typescripttsc -v 4.简化运行ts的步骤 5.typescript常用类型 类型检查机制 5.1 类型注解 5.2 常用基础类型 5.3 原始类型 6.数组类型 7.类型别名 type关键字 123456// 类型别名type CustomArray = (number|string)[]let arr1:CustomArray = [1,2,&#x27;a&#x27;,3]let arr2:CustomArray = [1,4,&#x27;a&#x27;,3]console.log(arr1);console.log(arr2); 8.函数类型 9.可选参数 10.对象类型对象的类型其实就是在描述对象的结构 11.对象中的可选属性 12.接口【复用】 1234567891011121314151617181920212223// 接口interface IPerson&#123; name:string age:number sayhi():void&#125;let person_3:IPerson =&#123; name:&#x27;JACL&#x27;, age:11, sayhi()&#123;&#125;&#125;let person_4:IPerson =&#123; name:&#x27;JAC33L&#x27;, age:33, sayhi()&#123;&#125;&#125;console.log(person_3);console.log(person_4); 13.接口和类型别名 12345type num = number | stringlet a:num = 1let b:num = &#x27;asf&#x27;console.log(a);console.log(b); 14.接口继承复用 15.元组 16.类型推论 17.类型断言 18.字面量类型 19.枚举类型 20.字符串枚举 21.枚举特点 22.any类型 23.ypeof 24.TS高级类型24.1 class 25.类的实例方法 26.类的继承 27.类成员可见性 28.类型兼容性 29.对象兼容性 30.接口兼容性 31.函数兼容性 32.类型兼容性 33.交叉类型 34.交叉类型(&amp;)和接口继承(extends)的区别 35.泛型 36.简化调用泛型函数 37.泛型循环 38.添加约束 39.泛型的类型变量 40.泛型接口41.JS中的数组就是TS中的一个泛型接口 42.class配合泛型来使用 43.泛型工具类型43.1 partial 43.2 readonly 43.3 pick 43.4 record 44.索引签名类型 45.映射类型45.1 基于旧类型进行创建 45.2 基于对象创建 45.3 引查询类型 45.4 同时查询多个索引的类型 46.d.ts 类型声明文件 47.TS中的两种文件类型 48.类型声明文件的使用说明 49.使用已有的类型声明文件49.1 内置api 49.2 第三方库的类型声明 49.3 definitelyTyped 49.4 创建自己的声明文件 49.5 项目内共享类型 49.6 为已有js文件提供类型声明 50.【webpack】搭建一个基本的webpack4.x项目51.React支持TS","categories":[{"name":"TypeScript","slug":"TypeScript","permalink":"http://example.com/categories/TypeScript/"}],"tags":[],"keywords":[{"name":"TypeScript","slug":"TypeScript","permalink":"http://example.com/categories/TypeScript/"}]},{"title":"面试题【Record】第一回","slug":"面试题【Record】第一回","date":"2024-02-20T14:00:41.000Z","updated":"2024-07-21T15:10:41.502Z","comments":true,"path":"2024/02/20/面试题【Record】第一回/","permalink":"http://example.com/2024/02/20/%E9%9D%A2%E8%AF%95%E9%A2%98%E3%80%90Record%E3%80%91%E7%AC%AC%E4%B8%80%E5%9B%9E/","excerpt":"","text":"如何判断一个对象为空？为什么data是一个函数?v-if与v-show的区别？用法与本质上的区别v-for中的key是什么作用? diff算法的实现原理虚拟DOM的作用？真实DOM &amp; 通过移动原生控件在移动端显示出来 &amp; 桌面端的一些控件 &amp; VR设备 –做跨平台computed 和 methods的区别？展开运算符的用法？获取Vue创建的代理的原始对象？toRawwatch的基本用法，以及侦听选项？deep immediate vue事件绑定如何传递参数?如何传递event参数?v-for中的key有什么作用?什么是虚拟DOM?什么是计算属性?和method有什么区别?如何在Vue中侦听一个数据的改变?v-model的原理? 什么是双向绑定?v-model的本质是什么?如何手动实现v-model?v-moder加上lazy、number、trim修饰符有什么作用？什么是组件化开发?有什么作用?什么是Vue CLl，如何使用它创建Vue项目? 脚手架创建项目的流程？Vue中注册全局组件和局部组件有什么区别?","categories":[{"name":"Record","slug":"Record","permalink":"http://example.com/categories/Record/"}],"tags":[],"keywords":[{"name":"Record","slug":"Record","permalink":"http://example.com/categories/Record/"}]}]}