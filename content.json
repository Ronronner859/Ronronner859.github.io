{"meta":{"title":"大白话说前端，多读源码多实践，勤于思考善领悟","subtitle":"","description":"我相信一万小时定律","author":"er dong yi","url":"http://example.com"},"pages":[],"posts":[{"title":"vue创建前端项目两种不同的方式","slug":"VUECLI的创建","date":"2024-07-21T14:00:41.000Z","updated":"2024-07-22T12:08:11.371Z","comments":true,"path":"2024/07/21/VUECLI的创建/","permalink":"http://example.com/2024/07/21/VUECLI%E7%9A%84%E5%88%9B%E5%BB%BA/","excerpt":"","text":"1.方式一【基于webpack构建】全局按照依赖包，通过vue create ‘xxx（项目名）’来创建具体步骤如下： 1.1 全局安装依赖包 (注意ode版本)npm install -g @vue/cli 1.2 创建一个项目1vue create project_demo 1.3 选择需要的版本或者手动选择特性 选择预设 选择特性 选择版本 选择配置是否单独放一个文件中 是否保存为一个预设 基于以上配置通过vue create命令基本创建完成。 目录介绍 2.方式二【基于vite构建】2.1 npm init vue@latest 1.安装一个本地工具，create-vue2.用create-vue创建一个vue项目 @latest 总是保持一个最新的版本 其他与webpack构建的基本是一致的。","categories":[{"name":"vue","slug":"vue","permalink":"http://example.com/categories/vue/"}],"tags":[],"keywords":[{"name":"vue","slug":"vue","permalink":"http://example.com/categories/vue/"}]},{"title":"JS_函数中this的指向多情况分析","slug":"JS01_函数中this的指向多情况分析","date":"2024-07-20T10:58:13.713Z","updated":"2024-07-22T02:47:10.399Z","comments":true,"path":"2024/07/20/JS01_函数中this的指向多情况分析/","permalink":"http://example.com/2024/07/20/JS01_%E5%87%BD%E6%95%B0%E4%B8%ADthis%E7%9A%84%E6%8C%87%E5%90%91%E5%A4%9A%E6%83%85%E5%86%B5%E5%88%86%E6%9E%90/","excerpt":"","text":"1.默认绑定默认绑定this都是指向的window全局对象 JS中只要定义了一个方法，那么该方法就会有this指向，然而在不同的情况this的指向也会有所不同 情况一：函数直接调用 情况二：通过对象调用 情况三：箭头函数调用 12345678910111213141516171819202122// 1.直接调用function foo() &#123; console.log(&#x27;this绑定规则一之默认绑定&#x27;); console.log(this)&#125;foo()// 2.函数定义在对象之后，但是独立调用var obj = &#123; name: &quot;John&quot;, bar:function ()&#123; console.log(&#x27;bar&#x27;,this) &#125;&#125;var bax = obj.barbax()// 3.高阶函数function test(fn)&#123; fn()&#125;test(obj.bar); 上面两种方式的调用this都是默认绑定，指向的window全局对象 补充：若是在严格模式”use strict”下，独立调用的函数的this指向是指向undefined 2.隐式绑定隐式绑定this指向的是某个对象发起的函数调用，指向这个对象本身 12345678// 也就是它的调用位置中，是通过某个对象发起的函数调用function foo() &#123; console.log(this)&#125;var x = &#123; bar:foo&#125;x.bar() this指向的是x这个对象本身。 3.new关键字使用new关键词时，会创建一个新的空对象，this指向这个空对象【简单解释】 12345678910111213function foo() &#123; console.log(this) this.name = &#x27;hello world&#x27;&#125; new foo()// foo()/*1.创建一个空对象2.将this指向这个空对象3.指向函数体中的代码4.没有显示返回的非空对象时，默认返回这个对象 */ 控制台打印结果为：foo {} 4.显示绑定apply、call、bind4.1 call函数可以执行call函数，强制this指向某一个对象，可以明确的告诉this绑定什么，直接了当 123456789101112var obj = &#123; name: &quot;John&quot;,&#125;function add() &#123; console.log(this)&#125;// obj.add = add// obj.add()// 执行函数，并且强制this就是obj对象 自己显示的明确告诉他绑定什么//执行函数，并且函数中的this指向obj对象add.call(obj)add.call(412) 4.2 apply函数apply函数主要与call的区别是传入的参数格式不同，都可以明白告诉this绑定什么 123456789101112131415161718192021/* 调用一起函数，同时绑定一个this */function foo(name,age,height)&#123; console.log(this) console.log(name,age,height)&#125;foo(&#x27;kobe&#x27;, 12, 1.98)/* 第一个参数：绑定this 第二个参数：传入额外的参数，以数组的形式 */foo.apply(&#x27;hello world&#x27;, [&#x27;kobe&#x27;, 12, 1.98]);/* 第一个参数：绑定this 参数列表：后续的参数是以多参数的一个形式的 */foo.call(&#x27;call&#x27;, &quot;zhangsan&quot;, 213, 2.07);// call 和 apply 第二个参数的传入的格式不一样 4.3 bind函数bind() 被调用时，这个新函数的 this 被指定为 bind() 的第一个参数，而其余参数将作为新函数的参数，供调用时进行使用 官方：Function.prototype.bind() Function 实例的 bind() 方法创建一个新函数，当调用该新函数时，它会调用原始函数并将其 this 关键字设置为给定的值，同时，还可以传入一系列指定的参数，这些参数会插入到调用新函数时传入的参数的前面。 1234567891011function foo()&#123; console.log(this)&#125;var obj = &#123;name:&#x27;john&#x27;&#125;// 需求:调用foo时，总是绑定到obj对象身上(不希望obj对象身上有函数)// 在 bind() 被调用时，这个新函数的 this 被指定为 bind() 的第一个参数，而其余参数将作为新函数的参数，供调用时进行使用 var bar = foo.bind(obj);bar()console.log(foo) 经典案例： 12345678910111213141516171819202122const module = &#123; x: 42, getX: function () &#123; console.log(&#x27;111&#x27;) return this.x; &#125;,&#125;;/** * unboundGetX 没有绑定到 module，所以 this 指向全局对象，导致返回 undefined。 * boundGetX 被绑定到 module，所以 this 指向 module，返回 42。 * */const unboundGetX = module.getX;// 全局下调用unboundGetX是this会指向全局对象windows nodejs中指向global 全局中无x，输出undefinedconsole.log(unboundGetX()); // The function gets invoked at the global scope// Expected output: undefined// bind 方法创建了一个新的函数，该函数的 this 永远指向 module。const boundGetX = unboundGetX.bind(module);console.log(boundGetX());// Expected output: 42 4.4 call()、apply()、bind()的区别及用法简单用法：都是用来改变this的指向 call、apply的一个区别： 相同点：都是调用一个对象的一个方法，用另一个对象替换当前对象（功能相同） 不同点：参数格式不同 call()的第一个参数是this要指向的对象，后面传入的是参数列表，参数可以是任意类型，当第一个参数为null、undefined的时候，默认指向window；apply()：第一个参数是this要指向的对象，第二个参数是数组[]call、bind的一个区别： 相同点: 都是用来改变this的指向 不同点：call改变this的指向后会再执行函数，bind改变this的指向后不会再执行函数，返回一个绑定新this的函数【React有用到】 用法：call函数 用来判断数据类型！ 延伸–判断数据类型的方式有哪几种？ 在判断数据类形式使用typeof，一般不是太准确的，我们可以使用Object.prototype.toString.call()方法来判断一个数据的数据类型 利用call()翻转字符串 用法：apply函数 进行求和计算 4.5 扩展：函数绑定的新姿势 ——ES7 bind 运算符（::） ES7 bind 运算符是一种新的绑定语法，它使用两个冒号 (::) 表示，通常被称为 “双冒号运算符” 或者 “作用域解析运算符”。它的作用是将一个函数绑定到一个特定的上下文中。bind 运算符始终将左边的表达式作为函数的上下文（即 this），右边的表达式作为函数名，同时还会将左边表达式中的属性和方法转移到右边表达式中。 6.this绑定规则优先级7.this绑定之外的规则8.箭头函数的写法arrow function9.箭头函数的简写arrow10.箭头函数实现所有偶数平方的和11.箭头函数中的this使用12.箭头函数中this的应用【模拟网络请求】","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/categories/JavaScript/"}],"tags":[],"keywords":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/categories/JavaScript/"}]},{"title":"关于Node的基本认识【BASIC】","slug":"Node.js【入门级】","date":"2024-05-20T14:00:41.000Z","updated":"2024-07-22T11:38:13.728Z","comments":true,"path":"2024/05/20/Node.js【入门级】/","permalink":"http://example.com/2024/05/20/Node.js%E3%80%90%E5%85%A5%E9%97%A8%E7%BA%A7%E3%80%91/","excerpt":"","text":"1可以脱离浏览器来执行js代码,没有DOM和BOM对象,针对后端可以编写接口，提供网页资源，前端可以集成各种工具（承上启下） node1.Buffer 2.Buffer相关操作 123456let buf = Buffer.alloc(10)console.log(buf);let buf_2 = Buffer.allocUnsafe(100)console.log(buf_2);let buf_3 = Buffer.from(&#x27;hello&#x27;)console.log(buf_3); 3.fs模块-读写模块【回顾一下liunx操作系统】【增删改查操作】 1与本机文件系统进行交互的，方法和属性 4.fs异步和同步 5.fs文件追加操作 6.文件写入的场景-【做持久化】 7.文件读取 8.写一个创建文件的脚本9.fs流式写入 10.exports对象12由于module.exports 单词写起来比较复杂，为了简化向外共享成员的代码，Node 提供了exports 对象。默认情况下，exports和module.exports 指向同一个对象。最终共享的结果，还是以module.exports指向的对象为准。时刻谨记，require()模块时，得到的永远是module.exports指向的对象: 11.计算机组成 12.模块化12345-require的使用-模块化的好处-&gt;无法共享成员-module对象，每个.js都自定义模块中都有一个module对象-exports 自定义模块中，可以使用exports将模块中的成员共享出去，给外界使用 在自定义模块中，默认情况下，module.export = &#123;&#125;使用require()方法导入模块时，导入的结果，永远以module.exports指向的对象为准。 13.模块化初体验 14.模块暴露数据 15.导入（引入）模块导入 js 和 json文件时 可以省略后缀 16.导入模块的基本流程 17.commonJS规范 18.包管理工具【哆啦A梦】 19.npm 20.npm基本使用20.1初始化 123456789101112&#123; &quot;name&quot;: &quot;test01&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;&quot;, &quot;main&quot;: &quot;index.js&quot;, &quot;scripts&quot;: &#123; &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot; &#125;, &quot;author&quot;: &quot;c&quot;, &quot;license&quot;: &quot;ISC&quot;&#125; 20.2如何搜索&#x2F;下载npm包 npmjs.com 20.3require导入包的基本流程 20.4开发依赖和生产依赖https://juejin.cn/post/7135795969370619918 20.5npm全局安装 20.6修改windows执行策略 21.环境变量path 20.1 npm安装包的所有依赖 22.安装指定版本的包 23.配置命令别名 24.cnpm 25.配置淘宝镜像 26.yarn 27.npm和yarn的使用 28.管理发布包 29.更新和删除 30.扩展 31.nvm 32.常用命令 33.expressJSExpress是一个流行的Node.js Web应用程序框架，用于构建服务器端应用程序。它提供了一组简洁而灵活的工具和中间件，使开发者可以轻松地构建RESTful API和Web应用。Express具有路由、请求和响应处理、中间件等功能，可以帮助开发者管理HTTP请求和构建服务器端逻辑。通过Express，可以搭建一个响应请求的服务器，处理前端发起的HTTP请求并返回相应的数据或页面。 34.简单应用35.路由 方法 路径 回调12345678910111213141516171819202122232425const express = require(&#x27;express&#x27;)const app = express()// 路由app.get(&#x27;/home&#x27;,(req,res) =&gt;&#123; res.end(&#x27;Welcome to the Home page&#x27;)&#125; )app.get(&#x27;/&#x27;,(req,res) =&gt;&#123; res.end(&#x27;Welcome to the Home page with instructions for creating&#x27;)&#125;)app.post(&#x27;/login&#x27;,(req,res) =&gt;&#123; res.end(&#x27;Welcome to the Login page&#x27;)&#125;)app.get(&#x27;*&#x27;,(req,res) =&gt;&#123; res.end(&#x27;404 Not Found &#x27;)&#125;)app.listen(3000,()=&gt;&#123; console.log(&#x27;listening on http://localhost&#x27;)&#125;) 36.获取请求参数 37.获取路由参数","categories":[{"name":"node","slug":"node","permalink":"http://example.com/categories/node/"}],"tags":[],"keywords":[{"name":"node","slug":"node","permalink":"http://example.com/categories/node/"}]},{"title":"浏览器【WebKit内核】渲染原理【QUESTION】","slug":"浏览器与JS的原理","date":"2024-04-20T14:00:41.000Z","updated":"2024-07-22T02:46:39.761Z","comments":true,"path":"2024/04/20/浏览器与JS的原理/","permalink":"http://example.com/2024/04/20/%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%8EJS%E7%9A%84%E5%8E%9F%E7%90%86/","excerpt":"","text":"1.浏览器输入一个网址（域名之后）,浏览器会呈现一个新的页面，中间的过程是怎么实现的？输入一个网址之后，首先DNS服务器会解析这个域名，将这个域名解析成IP地址，通过IP地址会访问到对应的服务器从该服务器中去请求资源，服务器首先会给浏览器返回index.html的静态资源，那么浏览器就可以通过一行行的从上到下的进行解析index.html文件【浏览器的内核：例如WebKit】，从而将HTML解析成一棵DOM树，如果中间有解析到link链接，就会去下载解析链接的内容，如css文件，但是这期间浏览器会继续向下进行解析，不会停留或者阻塞dom树的进行；下载完css文件后，会对css进行解析，生成cssom,称为css对象模型；通俗将也是一棵规则树。那么通过dom和cssom两棵树结合起来会生成一棵新的render tree。最后浏览器对这颗新的render tree的每个节点进行布局【排版引擎】和绘制到屏幕成，最终形成一个新个页面。 2.浏览器是如何解析服务器返回的静态资源的？然后呈现出页面的?https://web.dev/articles/howbrowserswork?hl=zh-cn html----&gt;dom css-----&gt;cssom 结合构建--------&gt;render tree 布局 ----- 绘制 ----- 呈现 3.什么是回流和重绘？第一次确定页面节点的大小和位置称为布局，当第二次重新计算页面节点的大小和位置成为回流 第一次渲染内容称为绘制，第二次重新渲染称为重绘 4.什么情况下会引起回流？什么情况下会引起重绘？1.DOM结构发生了改变 颜色、背景、样式等发生了改变 2.页面布局发生了改变 3.窗口resize发生了改变 5.怎么避免回流？样式尽量一次性修改 尽量频繁的操作DOM","categories":[{"name":"浏览器","slug":"浏览器","permalink":"http://example.com/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"}],"tags":[],"keywords":[{"name":"浏览器","slug":"浏览器","permalink":"http://example.com/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"}]},{"title":"一文知TypeScript的核心","slug":"颠覆认知的『TypeScript』【TS深度学习】","date":"2024-03-20T14:00:41.000Z","updated":"2024-07-21T04:36:07.563Z","comments":true,"path":"2024/03/20/颠覆认知的『TypeScript』【TS深度学习】/","permalink":"http://example.com/2024/03/20/%E9%A2%A0%E8%A6%86%E8%AE%A4%E7%9F%A5%E7%9A%84%E3%80%8ETypeScript%E3%80%8F%E3%80%90TS%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%91/","excerpt":"","text":"TypeSript【官网】【READBOOK】https://www.bookstack.cn/read/wangdoc-typescript-tutorial/docs-d.ts.md ts是js的一个超集，解决js类型支持js: 动态类型ts:静态类型 代码执行的顺序是先编译在执行 发现错误更早 1.为什么要添加类型支持？ 2.优势有什么？ 3.全局安装npm i -g typescripttsc -v 4.简化运行ts的步骤 5.typescript常用类型 类型检查机制 5.1 类型注解 5.2 常用基础类型 5.3 原始类型 6.数组类型 7.类型别名 type关键字 123456// 类型别名type CustomArray = (number|string)[]let arr1:CustomArray = [1,2,&#x27;a&#x27;,3]let arr2:CustomArray = [1,4,&#x27;a&#x27;,3]console.log(arr1);console.log(arr2); 8.函数类型 9.可选参数 10.对象类型对象的类型其实就是在描述对象的结构 11.对象中的可选属性 12.接口【复用】 1234567891011121314151617181920212223// 接口interface IPerson&#123; name:string age:number sayhi():void&#125;let person_3:IPerson =&#123; name:&#x27;JACL&#x27;, age:11, sayhi()&#123;&#125;&#125;let person_4:IPerson =&#123; name:&#x27;JAC33L&#x27;, age:33, sayhi()&#123;&#125;&#125;console.log(person_3);console.log(person_4); 13.接口和类型别名 12345type num = number | stringlet a:num = 1let b:num = &#x27;asf&#x27;console.log(a);console.log(b); 14.接口继承复用 15.元组 16.类型推论 17.类型断言 18.字面量类型 19.枚举类型 20.字符串枚举 21.枚举特点 22.any类型 23.ypeof 24.TS高级类型24.1 class 25.类的实例方法 26.类的继承 27.类成员可见性 28.类型兼容性 29.对象兼容性 30.接口兼容性 31.函数兼容性 32.类型兼容性 33.交叉类型 34.交叉类型(&amp;)和接口继承(extends)的区别 35.泛型 36.简化调用泛型函数 37.泛型循环 38.添加约束 39.泛型的类型变量 40.泛型接口41.JS中的数组就是TS中的一个泛型接口 42.class配合泛型来使用 43.泛型工具类型43.1 partial 43.2 readonly 43.3 pick 43.4 record 44.索引签名类型 45.映射类型45.1 基于旧类型进行创建 45.2 基于对象创建 45.3 引查询类型 45.4 同时查询多个索引的类型 46.d.ts 类型声明文件 47.TS中的两种文件类型 48.类型声明文件的使用说明 49.使用已有的类型声明文件49.1 内置api 49.2 第三方库的类型声明 49.3 definitelyTyped 49.4 创建自己的声明文件 49.5 项目内共享类型 49.6 为已有js文件提供类型声明 50.【webpack】搭建一个基本的webpack4.x项目51.React支持TS","categories":[{"name":"TypeScript","slug":"TypeScript","permalink":"http://example.com/categories/TypeScript/"}],"tags":[],"keywords":[{"name":"TypeScript","slug":"TypeScript","permalink":"http://example.com/categories/TypeScript/"}]},{"title":"面试题【Record】第一回","slug":"面试题【Record】第一回","date":"2024-02-20T14:00:41.000Z","updated":"2024-07-22T02:40:51.345Z","comments":true,"path":"2024/02/20/面试题【Record】第一回/","permalink":"http://example.com/2024/02/20/%E9%9D%A2%E8%AF%95%E9%A2%98%E3%80%90Record%E3%80%91%E7%AC%AC%E4%B8%80%E5%9B%9E/","excerpt":"","text":"如何判断一个对象为空？为什么data是一个函数?v-if与v-show的区别？用法与本质上的区别v-for中的key是什么作用? diff算法的实现原理虚拟DOM的作用？真实DOM &amp; 通过移动原生控件在移动端显示出来 &amp; 桌面端的一些控件 &amp; VR设备 –做跨平台computed 和 methods的区别？展开运算符的用法？获取Vue创建的代理的原始对象？toRawwatch的基本用法，以及侦听选项？deep immediate vue事件绑定如何传递参数?如何传递event参数?v-for中的key有什么作用?什么是虚拟DOM?什么是计算属性?和method有什么区别?如何在Vue中侦听一个数据的改变?v-model的原理? 什么是双向绑定?v-model的本质是什么?如何手动实现v-model?v-moder加上lazy、number、trim修饰符有什么作用？什么是组件化开发?有什么作用?什么是Vue CLl，如何使用它创建Vue项目? 脚手架创建项目的流程？Vue中注册全局组件和局部组件有什么区别?","categories":[{"name":"Record","slug":"Record","permalink":"http://example.com/categories/Record/"}],"tags":[],"keywords":[{"name":"Record","slug":"Record","permalink":"http://example.com/categories/Record/"}]}]}