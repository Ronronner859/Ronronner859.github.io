{"meta":{"title":"大白话说前端，多读源码多实践，勤于思考善领悟","subtitle":"","description":"我相信一万小时定律","author":"er dong yi","url":"http://example.com"},"pages":[],"posts":[{"title":"话说设计模式","slug":"设计模式","date":"2024-09-17T07:00:00.000Z","updated":"2024-09-17T14:35:20.204Z","comments":true,"path":"2024/09/17/设计模式/","permalink":"http://example.com/2024/09/17/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"不同的业务场景可以采用不同的设计模式 1.构造器模式可以批量生产对象 构造器模式是一种创建对象的设计模式，它提供了一种创建对象的方式，而不需要暴露内部结构。 构造器模式的主要优点是： \\1. 可以隐藏对象的创建细节，使代码更加简洁。 \\2. 可以方便地修改对象的创建方式，而不需要修改客户端代码。 \\3. 可以方便地创建多个对象，而不需要重复编写代码。 然而：say()方法每次都要生成；非常冗余；统称搭配原型来使用！ 2.原型模式 es6 语法：利用 calss 类的方式构造（构造器） 其中 say()方法自动装载到了原型之上。 实际应用场景 tab 栏案例 3.工厂模式 应用场景：权限管理（不同的角色有不同的权限） es6 语法 4.抽象工厂模式","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[],"keywords":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"01-Vue3源码阅读","slug":"【REVIEW】01- vue源码阅读","date":"2024-09-05T01:43:39.341Z","updated":"2024-09-17T14:33:38.782Z","comments":true,"path":"2024/09/05/【REVIEW】01- vue源码阅读/","permalink":"http://example.com/2024/09/05/%E3%80%90REVIEW%E3%80%9101-%20vue%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/","excerpt":"","text":"","categories":[{"name":"vue3","slug":"vue3","permalink":"http://example.com/categories/vue3/"}],"tags":[],"keywords":[{"name":"vue3","slug":"vue3","permalink":"http://example.com/categories/vue3/"}]},{"title":"v-for指令中key&虚拟dom&diff算法【QUESTION】","slug":"v-for中的key有什么作用什么是虚拟DOM","date":"2024-07-22T14:00:41.000Z","updated":"2024-07-22T12:19:19.869Z","comments":true,"path":"2024/07/22/v-for中的key有什么作用什么是虚拟DOM/","permalink":"http://example.com/2024/07/22/v-for%E4%B8%AD%E7%9A%84key%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%E4%BB%80%E4%B9%88%E6%98%AF%E8%99%9A%E6%8B%9FDOM/","excerpt":"","text":"1.认识一下v-for的作用简单说，vue可以使用v-for来遍历元素 2.重点说一下key属性那么在属性中，绑定key和不绑定key的一个区别是什么？ key属性主要用在Vue的虚拟DOM算法，在新I日nodes对比时辨识VNodes 如果不使用key，Vue会使用一种最大限度减少动态元素并且尽可能的尝试就地修改/复用相同类型元素的算法; 而使用key时，它会基于key的变化重新排列元素顺序，并且会移除/销毁key不存在的元素; 底层主要实现的是diff算法 有key或无key主要vnode是否进行复用的一个操作 有key可以提升浏览器渲染生成真实DOM的一个性能的","categories":[{"name":"vue","slug":"vue","permalink":"http://example.com/categories/vue/"}],"tags":[],"keywords":[{"name":"vue","slug":"vue","permalink":"http://example.com/categories/vue/"}]},{"title":"vue创建前端项目两种不同的方式","slug":"VUECLI的创建","date":"2024-07-21T14:00:41.000Z","updated":"2024-07-22T12:08:11.371Z","comments":true,"path":"2024/07/21/VUECLI的创建/","permalink":"http://example.com/2024/07/21/VUECLI%E7%9A%84%E5%88%9B%E5%BB%BA/","excerpt":"","text":"1.方式一【基于webpack构建】全局按照依赖包，通过vue create ‘xxx（项目名）’来创建具体步骤如下： 1.1 全局安装依赖包 (注意ode版本)npm install -g @vue/cli 1.2 创建一个项目1vue create project_demo 1.3 选择需要的版本或者手动选择特性 选择预设 选择特性 选择版本 选择配置是否单独放一个文件中 是否保存为一个预设 基于以上配置通过vue create命令基本创建完成。 目录介绍 2.方式二【基于vite构建】2.1 npm init vue@latest 1.安装一个本地工具，create-vue2.用create-vue创建一个vue项目 @latest 总是保持一个最新的版本 其他与webpack构建的基本是一致的。","categories":[{"name":"vue","slug":"vue","permalink":"http://example.com/categories/vue/"}],"tags":[],"keywords":[{"name":"vue","slug":"vue","permalink":"http://example.com/categories/vue/"}]},{"title":"JS_函数中this的指向多情况分析","slug":"JS01_函数中this的指向多情况分析","date":"2024-07-20T10:58:13.713Z","updated":"2024-07-22T02:47:10.399Z","comments":true,"path":"2024/07/20/JS01_函数中this的指向多情况分析/","permalink":"http://example.com/2024/07/20/JS01_%E5%87%BD%E6%95%B0%E4%B8%ADthis%E7%9A%84%E6%8C%87%E5%90%91%E5%A4%9A%E6%83%85%E5%86%B5%E5%88%86%E6%9E%90/","excerpt":"","text":"1.默认绑定默认绑定this都是指向的window全局对象 JS中只要定义了一个方法，那么该方法就会有this指向，然而在不同的情况this的指向也会有所不同 情况一：函数直接调用 情况二：通过对象调用 情况三：箭头函数调用 12345678910111213141516171819202122// 1.直接调用function foo() &#123; console.log(&#x27;this绑定规则一之默认绑定&#x27;); console.log(this)&#125;foo()// 2.函数定义在对象之后，但是独立调用var obj = &#123; name: &quot;John&quot;, bar:function ()&#123; console.log(&#x27;bar&#x27;,this) &#125;&#125;var bax = obj.barbax()// 3.高阶函数function test(fn)&#123; fn()&#125;test(obj.bar); 上面两种方式的调用this都是默认绑定，指向的window全局对象 补充：若是在严格模式”use strict”下，独立调用的函数的this指向是指向undefined 2.隐式绑定隐式绑定this指向的是某个对象发起的函数调用，指向这个对象本身 12345678// 也就是它的调用位置中，是通过某个对象发起的函数调用function foo() &#123; console.log(this)&#125;var x = &#123; bar:foo&#125;x.bar() this指向的是x这个对象本身。 3.new关键字使用new关键词时，会创建一个新的空对象，this指向这个空对象【简单解释】 12345678910111213function foo() &#123; console.log(this) this.name = &#x27;hello world&#x27;&#125; new foo()// foo()/*1.创建一个空对象2.将this指向这个空对象3.指向函数体中的代码4.没有显示返回的非空对象时，默认返回这个对象 */ 控制台打印结果为：foo {} 4.显示绑定apply、call、bind4.1 call函数可以执行call函数，强制this指向某一个对象，可以明确的告诉this绑定什么，直接了当 123456789101112var obj = &#123; name: &quot;John&quot;,&#125;function add() &#123; console.log(this)&#125;// obj.add = add// obj.add()// 执行函数，并且强制this就是obj对象 自己显示的明确告诉他绑定什么//执行函数，并且函数中的this指向obj对象add.call(obj)add.call(412) 4.2 apply函数apply函数主要与call的区别是传入的参数格式不同，都可以明白告诉this绑定什么 123456789101112131415161718192021/* 调用一起函数，同时绑定一个this */function foo(name,age,height)&#123; console.log(this) console.log(name,age,height)&#125;foo(&#x27;kobe&#x27;, 12, 1.98)/* 第一个参数：绑定this 第二个参数：传入额外的参数，以数组的形式 */foo.apply(&#x27;hello world&#x27;, [&#x27;kobe&#x27;, 12, 1.98]);/* 第一个参数：绑定this 参数列表：后续的参数是以多参数的一个形式的 */foo.call(&#x27;call&#x27;, &quot;zhangsan&quot;, 213, 2.07);// call 和 apply 第二个参数的传入的格式不一样 4.3 bind函数bind() 被调用时，这个新函数的 this 被指定为 bind() 的第一个参数，而其余参数将作为新函数的参数，供调用时进行使用 官方：Function.prototype.bind() Function 实例的 bind() 方法创建一个新函数，当调用该新函数时，它会调用原始函数并将其 this 关键字设置为给定的值，同时，还可以传入一系列指定的参数，这些参数会插入到调用新函数时传入的参数的前面。 1234567891011function foo()&#123; console.log(this)&#125;var obj = &#123;name:&#x27;john&#x27;&#125;// 需求:调用foo时，总是绑定到obj对象身上(不希望obj对象身上有函数)// 在 bind() 被调用时，这个新函数的 this 被指定为 bind() 的第一个参数，而其余参数将作为新函数的参数，供调用时进行使用 var bar = foo.bind(obj);bar()console.log(foo) 经典案例： 12345678910111213141516171819202122const module = &#123; x: 42, getX: function () &#123; console.log(&#x27;111&#x27;) return this.x; &#125;,&#125;;/** * unboundGetX 没有绑定到 module，所以 this 指向全局对象，导致返回 undefined。 * boundGetX 被绑定到 module，所以 this 指向 module，返回 42。 * */const unboundGetX = module.getX;// 全局下调用unboundGetX是this会指向全局对象windows nodejs中指向global 全局中无x，输出undefinedconsole.log(unboundGetX()); // The function gets invoked at the global scope// Expected output: undefined// bind 方法创建了一个新的函数，该函数的 this 永远指向 module。const boundGetX = unboundGetX.bind(module);console.log(boundGetX());// Expected output: 42 4.4 call()、apply()、bind()的区别及用法简单用法：都是用来改变this的指向 call、apply的一个区别： 相同点：都是调用一个对象的一个方法，用另一个对象替换当前对象（功能相同） 不同点：参数格式不同 call()的第一个参数是this要指向的对象，后面传入的是参数列表，参数可以是任意类型，当第一个参数为null、undefined的时候，默认指向window；apply()：第一个参数是this要指向的对象，第二个参数是数组[]call、bind的一个区别： 相同点: 都是用来改变this的指向 不同点：call改变this的指向后会再执行函数，bind改变this的指向后不会再执行函数，返回一个绑定新this的函数【React有用到】 用法：call函数 用来判断数据类型！ 延伸–判断数据类型的方式有哪几种？ 在判断数据类形式使用typeof，一般不是太准确的，我们可以使用Object.prototype.toString.call()方法来判断一个数据的数据类型 利用call()翻转字符串 用法：apply函数 进行求和计算 4.5 扩展：函数绑定的新姿势 ——ES7 bind 运算符（::） ES7 bind 运算符是一种新的绑定语法，它使用两个冒号 (::) 表示，通常被称为 “双冒号运算符” 或者 “作用域解析运算符”。它的作用是将一个函数绑定到一个特定的上下文中。bind 运算符始终将左边的表达式作为函数的上下文（即 this），右边的表达式作为函数名，同时还会将左边表达式中的属性和方法转移到右边表达式中。 6.this绑定规则优先级7.this绑定之外的规则8.箭头函数的写法arrow function9.箭头函数的简写arrow10.箭头函数实现所有偶数平方的和11.箭头函数中的this使用12.箭头函数中this的应用【模拟网络请求】","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/categories/JavaScript/"}],"tags":[],"keywords":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/categories/JavaScript/"}]},{"title":"promise的网络请求库，作用于node.js 和浏览器中【REVIEW】","slug":"Axios","date":"2024-06-21T14:00:41.000Z","updated":"2024-07-22T12:50:05.047Z","comments":true,"path":"2024/06/21/Axios/","permalink":"http://example.com/2024/06/21/Axios/","excerpt":"","text":"1. Axioshttps://axios-http.com/https://www.bootcss.com/前置知识： promise ajax 2. json-serverhttps://github.com/typicode/json-server 3. 安装1$ npm install axios 3. 项目开始国内引入：https://www.bootcdn.cn/axios/ 4. 发送请求5. GET12345678910const btns = document.querySelectorAll(&#x27;button&#x27;)btns[0].onclick = function ()&#123; axios(&#123; method:&#x27;GET&#x27;, url:&#x27;http://localhost:3000/posts/2&#x27; &#125;).then(response =&gt;&#123; console.log(response) &#125;)&#125; 响应200 查看请求头 6. POST12345678910111213btns[1].onclick = function ()&#123; axios(&#123; method:&#x27;POST&#x27;, url:&#x27;http://localhost:3000/posts&#x27;, // 请求体 data:&#123; title:&quot;hello&quot;, views: 120 &#125; &#125;).then(response =&gt;&#123; console.log(response) &#125;)&#125; 7. PUT12345678910111213btns[2].onclick = function ()&#123; axios(&#123; method:&#x27;PUT&#x27;, url:&#x27;http://localhost:3000/posts/2&#x27;, // 请求体 data:&#123; title:&quot;WORLD&quot;, views: 1000 &#125; &#125;).then(response =&gt;&#123; console.log(response) &#125;)&#125; 8. DELETE12345678btns[3].onclick = function ()&#123; axios(&#123; method:&#x27;DELETE&#x27;, url:&#x27;http://localhost:3000/posts/1&#x27;, &#125;).then(response =&gt;&#123; console.log(response) &#125;)&#125; 9. 其他发送请求123456789axios#request(config)axios#get(url[, config])axios#delete(url[, config])axios#head(url[, config])axios#options(url[, config])axios#post(url[, data[, config]])axios#put(url[, data[, config]])axios#patch(url[, data[, config]])axios#getUri([config]) 10. 请求配置这些是创建请求时可以用的配置选项。只有 url 是必需的。如果没有指定 method，请求将默认使用 GET 方法。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161&#123; // `url` 是用于请求的服务器 URL url: &#x27;/user&#x27;, // `method` 是创建请求时使用的方法 method: &#x27;get&#x27;, // 默认值 // `baseURL` 将自动加在 `url` 前面，除非 `url` 是一个绝对 URL。 // 它可以通过设置一个 `baseURL` 便于为 axios 实例的方法传递相对 URL baseURL: &#x27;https://some-domain.com/api/&#x27;, // `transformRequest` 允许在向服务器发送前，修改请求数据 // 它只能用于 &#x27;PUT&#x27;, &#x27;POST&#x27; 和 &#x27;PATCH&#x27; 这几个请求方法 // 数组中最后一个函数必须返回一个字符串， 一个Buffer实例，ArrayBuffer，FormData，或 Stream // 你可以修改请求头。 transformRequest: [function (data, headers) &#123; // 对发送的 data 进行任意转换处理 return data; &#125;], // `transformResponse` 在传递给 then/catch 前，允许修改响应数据 transformResponse: [function (data) &#123; // 对接收的 data 进行任意转换处理 return data; &#125;], // 自定义请求头 headers: &#123;&#x27;X-Requested-With&#x27;: &#x27;XMLHttpRequest&#x27;&#125;, // `params` 是与请求一起发送的 URL 参数 // 必须是一个简单对象或 URLSearchParams 对象 params: &#123; ID: 12345 &#125;, // `paramsSerializer`是可选方法，主要用于序列化`params` // (e.g. https://www.npmjs.com/package/qs, http://api.jquery.com/jquery.param/) paramsSerializer: function (params) &#123; return Qs.stringify(params, &#123;arrayFormat: &#x27;brackets&#x27;&#125;) &#125;, // `data` 是作为请求体被发送的数据 // 仅适用 &#x27;PUT&#x27;, &#x27;POST&#x27;, &#x27;DELETE 和 &#x27;PATCH&#x27; 请求方法 // 在没有设置 `transformRequest` 时，则必须是以下类型之一: // - string, plain object, ArrayBuffer, ArrayBufferView, URLSearchParams // - 浏览器专属: FormData, File, Blob // - Node 专属: Stream, Buffer data: &#123; firstName: &#x27;Fred&#x27; &#125;, // 发送请求体数据的可选语法 // 请求方式 post // 只有 value 会被发送，key 则不会 data: &#x27;Country=Brasil&amp;City=Belo Horizonte&#x27;, // `timeout` 指定请求超时的毫秒数。 // 如果请求时间超过 `timeout` 的值，则请求会被中断 timeout: 1000, // 默认值是 `0` (永不超时) // `withCredentials` 表示跨域请求时是否需要使用凭证 withCredentials: false, // default // `adapter` 允许自定义处理请求，这使测试更加容易。 // 返回一个 promise 并提供一个有效的响应 （参见 lib/adapters/README.md）。 adapter: function (config) &#123; /* ... */ &#125;, // `auth` HTTP Basic Auth auth: &#123; username: &#x27;janedoe&#x27;, password: &#x27;s00pers3cret&#x27; &#125;, // `responseType` 表示浏览器将要响应的数据类型 // 选项包括: &#x27;arraybuffer&#x27;, &#x27;document&#x27;, &#x27;json&#x27;, &#x27;text&#x27;, &#x27;stream&#x27; // 浏览器专属：&#x27;blob&#x27; responseType: &#x27;json&#x27;, // 默认值 // `responseEncoding` 表示用于解码响应的编码 (Node.js 专属) // 注意：忽略 `responseType` 的值为 &#x27;stream&#x27;，或者是客户端请求 // Note: Ignored for `responseType` of &#x27;stream&#x27; or client-side requests responseEncoding: &#x27;utf8&#x27;, // 默认值 // `xsrfCookieName` 是 xsrf token 的值，被用作 cookie 的名称 xsrfCookieName: &#x27;XSRF-TOKEN&#x27;, // 默认值 // `xsrfHeaderName` 是带有 xsrf token 值的http 请求头名称 xsrfHeaderName: &#x27;X-XSRF-TOKEN&#x27;, // 默认值 // `onUploadProgress` 允许为上传处理进度事件 // 浏览器专属 onUploadProgress: function (progressEvent) &#123; // 处理原生进度事件 &#125;, // `onDownloadProgress` 允许为下载处理进度事件 // 浏览器专属 onDownloadProgress: function (progressEvent) &#123; // 处理原生进度事件 &#125;, // `maxContentLength` 定义了node.js中允许的HTTP响应内容的最大字节数 maxContentLength: 2000, // `maxBodyLength`（仅Node）定义允许的http请求内容的最大字节数 maxBodyLength: 2000, // `validateStatus` 定义了对于给定的 HTTP状态码是 resolve 还是 reject promise。 // 如果 `validateStatus` 返回 `true` (或者设置为 `null` 或 `undefined`)， // 则promise 将会 resolved，否则是 rejected。 validateStatus: function (status) &#123; return status &gt;= 200 &amp;&amp; status &lt; 300; // 默认值 &#125;, // `maxRedirects` 定义了在node.js中要遵循的最大重定向数。 // 如果设置为0，则不会进行重定向 maxRedirects: 5, // 默认值 // `socketPath` 定义了在node.js中使用的UNIX套接字。 // e.g. &#x27;/var/run/docker.sock&#x27; 发送请求到 docker 守护进程。 // 只能指定 `socketPath` 或 `proxy` 。 // 若都指定，这使用 `socketPath` 。 socketPath: null, // default // `httpAgent` and `httpsAgent` define a custom agent to be used when performing http // and https requests, respectively, in node.js. This allows options to be added like // `keepAlive` that are not enabled by default. httpAgent: new http.Agent(&#123; keepAlive: true &#125;), httpsAgent: new https.Agent(&#123; keepAlive: true &#125;), // `proxy` 定义了代理服务器的主机名，端口和协议。 // 您可以使用常规的`http_proxy` 和 `https_proxy` 环境变量。 // 使用 `false` 可以禁用代理功能，同时环境变量也会被忽略。 // `auth`表示应使用HTTP Basic auth连接到代理，并且提供凭据。 // 这将设置一个 `Proxy-Authorization` 请求头，它会覆盖 `headers` 中已存在的自定义 `Proxy-Authorization` 请求头。 // 如果代理服务器使用 HTTPS，则必须设置 protocol 为`https` proxy: &#123; protocol: &#x27;https&#x27;, host: &#x27;127.0.0.1&#x27;, port: 9000, auth: &#123; username: &#x27;mikeymike&#x27;, password: &#x27;rapunz3l&#x27; &#125; &#125;, // see https://axios-http.com/zh/docs/cancellation cancelToken: new CancelToken(function (cancel) &#123; &#125;), // `decompress` indicates whether or not the response body should be decompressed // automatically. If set to `true` will also remove the &#x27;content-encoding&#x27; header // from the responses objects of all decompressed responses // - Node only (XHR cannot turn off decompression) decompress: true // 默认值&#125; 11. axios响应信息 config 配置对象 data 响应体 header 响应头信息 request 原生的ajax对象 status statusText 1234567891011121314151617181920212223&#123; // `data` 由服务器提供的响应 data: &#123;&#125;, // `status` 来自服务器响应的 HTTP 状态码 status: 200, // `statusText` 来自服务器响应的 HTTP 状态信息 statusText: &#x27;OK&#x27;, // `headers` 是服务器响应头 // 所有的 header 名称都是小写，而且可以使用方括号语法访问 // 例如: `response.headers[&#x27;content-type&#x27;]` headers: &#123;&#125;, // `config` 是 `axios` 请求的配置信息 config: &#123;&#125;, // `request` 是生成此响应的请求 // 在node.js中它是最后一个ClientRequest实例 (in redirects)， // 在浏览器中则是 XMLHttpRequest 实例 request: &#123;&#125;&#125; 12. axios默认配置123456789101112131415161718192021222324252627282930313233343536373839&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;axios基本使用&lt;/title&gt; &lt;link crossorigin=&quot;anonymous&quot; href=&quot;https://cdn.bootcss.com/twitter-bootstrap/3.3.7/css/bootstrap.min.css&quot; rel=&quot;stylesheet&quot;&gt; &lt;script src=&quot;https://cdn.bootcdn.net/ajax/libs/axios/0.21.1/axios.min.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;container&quot;&gt; &lt;h2 class=&quot;page-header&quot;&gt;基本使用&lt;/h2&gt; &lt;button class=&quot;btn btn-primary&quot;&gt; 发送GET请求 &lt;/button&gt; &lt;button class=&quot;btn btn-warning&quot; &gt; 发送POST请求 &lt;/button&gt; &lt;button class=&quot;btn btn-success&quot;&gt; 发送 PUT 请求 &lt;/button&gt; &lt;button class=&quot;btn btn-danger&quot;&gt; 发送 DELETE 请求 &lt;/button&gt; &lt;/div&gt; &lt;script&gt; //获取按钮 const btns = document.querySelectorAll(&#x27;button&#x27;); //默认配置 axios.defaults.method = &#x27;GET&#x27;;//设置默认的请求类型为 GET axios.defaults.baseURL = &#x27;http://localhost:3000&#x27;;//设置基础 URL axios.defaults.params = &#123;id:100&#125;; axios.defaults.timeout = 3000;// btns[0].onclick = function()&#123; axios(&#123; url: &#x27;/posts&#x27; &#125;).then(response =&gt; &#123; console.log(response); &#125;) &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"http网络","slug":"http网络","permalink":"http://example.com/categories/http%E7%BD%91%E7%BB%9C/"}],"tags":[],"keywords":[{"name":"http网络","slug":"http网络","permalink":"http://example.com/categories/http%E7%BD%91%E7%BB%9C/"}]},{"title":"关于Node的基本认识【BASIC】","slug":"Node.js【入门级】","date":"2024-05-20T14:00:41.000Z","updated":"2024-07-22T11:38:13.728Z","comments":true,"path":"2024/05/20/Node.js【入门级】/","permalink":"http://example.com/2024/05/20/Node.js%E3%80%90%E5%85%A5%E9%97%A8%E7%BA%A7%E3%80%91/","excerpt":"","text":"1可以脱离浏览器来执行js代码,没有DOM和BOM对象,针对后端可以编写接口，提供网页资源，前端可以集成各种工具（承上启下） node1.Buffer 2.Buffer相关操作 123456let buf = Buffer.alloc(10)console.log(buf);let buf_2 = Buffer.allocUnsafe(100)console.log(buf_2);let buf_3 = Buffer.from(&#x27;hello&#x27;)console.log(buf_3); 3.fs模块-读写模块【回顾一下liunx操作系统】【增删改查操作】 1与本机文件系统进行交互的，方法和属性 4.fs异步和同步 5.fs文件追加操作 6.文件写入的场景-【做持久化】 7.文件读取 8.写一个创建文件的脚本9.fs流式写入 10.exports对象12由于module.exports 单词写起来比较复杂，为了简化向外共享成员的代码，Node 提供了exports 对象。默认情况下，exports和module.exports 指向同一个对象。最终共享的结果，还是以module.exports指向的对象为准。时刻谨记，require()模块时，得到的永远是module.exports指向的对象: 11.计算机组成 12.模块化12345-require的使用-模块化的好处-&gt;无法共享成员-module对象，每个.js都自定义模块中都有一个module对象-exports 自定义模块中，可以使用exports将模块中的成员共享出去，给外界使用 在自定义模块中，默认情况下，module.export = &#123;&#125;使用require()方法导入模块时，导入的结果，永远以module.exports指向的对象为准。 13.模块化初体验 14.模块暴露数据 15.导入（引入）模块导入 js 和 json文件时 可以省略后缀 16.导入模块的基本流程 17.commonJS规范 18.包管理工具【哆啦A梦】 19.npm 20.npm基本使用20.1初始化 123456789101112&#123; &quot;name&quot;: &quot;test01&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;&quot;, &quot;main&quot;: &quot;index.js&quot;, &quot;scripts&quot;: &#123; &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot; &#125;, &quot;author&quot;: &quot;c&quot;, &quot;license&quot;: &quot;ISC&quot;&#125; 20.2如何搜索&#x2F;下载npm包 npmjs.com 20.3require导入包的基本流程 20.4开发依赖和生产依赖https://juejin.cn/post/7135795969370619918 20.5npm全局安装 20.6修改windows执行策略 21.环境变量path 20.1 npm安装包的所有依赖 22.安装指定版本的包 23.配置命令别名 24.cnpm 25.配置淘宝镜像 26.yarn 27.npm和yarn的使用 28.管理发布包 29.更新和删除 30.扩展 31.nvm 32.常用命令 33.expressJSExpress是一个流行的Node.js Web应用程序框架，用于构建服务器端应用程序。它提供了一组简洁而灵活的工具和中间件，使开发者可以轻松地构建RESTful API和Web应用。Express具有路由、请求和响应处理、中间件等功能，可以帮助开发者管理HTTP请求和构建服务器端逻辑。通过Express，可以搭建一个响应请求的服务器，处理前端发起的HTTP请求并返回相应的数据或页面。 34.简单应用35.路由 方法 路径 回调12345678910111213141516171819202122232425const express = require(&#x27;express&#x27;)const app = express()// 路由app.get(&#x27;/home&#x27;,(req,res) =&gt;&#123; res.end(&#x27;Welcome to the Home page&#x27;)&#125; )app.get(&#x27;/&#x27;,(req,res) =&gt;&#123; res.end(&#x27;Welcome to the Home page with instructions for creating&#x27;)&#125;)app.post(&#x27;/login&#x27;,(req,res) =&gt;&#123; res.end(&#x27;Welcome to the Login page&#x27;)&#125;)app.get(&#x27;*&#x27;,(req,res) =&gt;&#123; res.end(&#x27;404 Not Found &#x27;)&#125;)app.listen(3000,()=&gt;&#123; console.log(&#x27;listening on http://localhost&#x27;)&#125;) 36.获取请求参数 37.获取路由参数","categories":[{"name":"node","slug":"node","permalink":"http://example.com/categories/node/"}],"tags":[],"keywords":[{"name":"node","slug":"node","permalink":"http://example.com/categories/node/"}]},{"title":"浏览器【WebKit内核】渲染原理【QUESTION】","slug":"浏览器与JS的原理","date":"2024-04-20T14:00:41.000Z","updated":"2024-07-22T15:29:02.864Z","comments":true,"path":"2024/04/20/浏览器与JS的原理/","permalink":"http://example.com/2024/04/20/%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%8EJS%E7%9A%84%E5%8E%9F%E7%90%86/","excerpt":"","text":"1.浏览器输入一个网址（域名之后）,浏览器会呈现一个新的页面，中间的过程是怎么实现的？输入一个网址之后，首先DNS服务器会解析这个域名，将这个域名解析成IP地址，通过IP地址会访问到对应的服务器从该服务器中去请求资源，服务器首先会给浏览器返回index.html的静态资源，那么浏览器就可以通过一行行的从上到下的进行解析index.html文件【浏览器的内核：例如WebKit】，从而将HTML解析成一棵DOM树，如果中间有解析到link链接，就会去下载解析链接的内容，如css文件，但是这期间浏览器会继续向下进行解析，不会停留或者阻塞dom树的进行；下载完css文件后，会对css进行解析，生成cssom,称为css对象模型；通俗将也是一棵规则树。那么通过dom和cssom两棵树结合起来会生成一棵新的render tree。最后浏览器对这颗新的render tree的每个节点进行布局【排版引擎】和绘制到屏幕成，最终形成一个新个页面。 2.浏览器是如何解析服务器返回的静态资源的？然后呈现出页面的?https://web.dev/articles/howbrowserswork?hl=zh-cn html----&gt;dom css-----&gt;cssom 结合构建--------&gt;render tree 布局 ----- 绘制 ----- 呈现 3.什么是回流和重绘？第一次确定页面节点的大小和位置称为布局，当第二次重新计算页面节点的大小和位置成为回流 第一次渲染内容称为绘制，第二次重新渲染称为重绘 4.什么情况下会引起回流？什么情况下会引起重绘？1.DOM结构发生了改变 颜色、背景、样式等发生了改变 2.页面布局发生了改变 3.窗口resize发生了改变 5.怎么避免回流？样式尽量一次性修改 尽量频繁的操作DOM","categories":[{"name":"浏览器","slug":"浏览器","permalink":"http://example.com/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"}],"tags":[],"keywords":[{"name":"浏览器","slug":"浏览器","permalink":"http://example.com/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"}]},{"title":"React【文档学习】04","slug":"React04","date":"2024-03-24T14:00:41.000Z","updated":"2024-07-24T09:02:34.162Z","comments":true,"path":"2024/03/24/React04/","permalink":"http://example.com/2024/03/24/React04/","excerpt":"","text":"","categories":[{"name":"React","slug":"React","permalink":"http://example.com/categories/React/"}],"tags":[],"keywords":[{"name":"React","slug":"React","permalink":"http://example.com/categories/React/"}]},{"title":"React【文档学习】03","slug":"React03","date":"2024-03-23T14:00:41.000Z","updated":"2024-07-24T09:02:07.790Z","comments":true,"path":"2024/03/23/React03/","permalink":"http://example.com/2024/03/23/React03/","excerpt":"","text":"","categories":[{"name":"React","slug":"React","permalink":"http://example.com/categories/React/"}],"tags":[],"keywords":[{"name":"React","slug":"React","permalink":"http://example.com/categories/React/"}]},{"title":"React【文档学习】02","slug":"React02","date":"2024-03-22T14:00:41.000Z","updated":"2024-07-24T09:01:51.436Z","comments":true,"path":"2024/03/22/React02/","permalink":"http://example.com/2024/03/22/React02/","excerpt":"","text":"","categories":[{"name":"React","slug":"React","permalink":"http://example.com/categories/React/"}],"tags":[],"keywords":[{"name":"React","slug":"React","permalink":"http://example.com/categories/React/"}]},{"title":"React【文档学习】01","slug":"React01","date":"2024-03-21T14:00:41.000Z","updated":"2024-07-24T08:59:18.842Z","comments":true,"path":"2024/03/21/React01/","permalink":"http://example.com/2024/03/21/React01/","excerpt":"","text":"React【文档学习】011. react是什么 官方文档 查阅书籍 练习github项目 https://zh-hans.reactis.org/ 声明式 组件化 跨平台 2. 声明式编程 3. 组件化开发 4. 多平台适配 5. React开发依赖&amp;引入方式 CDN引入 下载引入 npm下载引入（脚手架） 12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;hello react&lt;/title&gt;&lt;!-- 需要依赖三个包--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/react@18/umd/react.development.js&quot;&gt;&lt;/script&gt; &lt;script crossorigin src=&quot;https://unpkg.com/react-dom@18/umd/react-dom.development.js&quot;&gt;&lt;/script&gt;&lt;!-- babel 将jsx 转成 js--&gt; &lt;script src=&quot;https://unpkg.com/babel-standalone@6/babel.min.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;root&quot;&gt; &lt;/div&gt; &lt;div id=&quot;app&quot;&gt; &lt;/div&gt; &lt;script type=&quot;text/babel&quot;&gt; // ReactDOM.render() react 18之前 的语法 // ReactDOM.render(vdom,document.getElementById(&#x27;app&#x27;)); const root = ReactDOM.createRoot(document.querySelector(&#x27;#root&#x27;)); root.render(&lt;h1&gt;Hello, world!&lt;/h1&gt;); // const app = ReactDOM.createRoot(document.querySelector(&#x27;#app&#x27;)); // app.render(&lt;h1&gt;Hello, React!&lt;/h1&gt;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 6. babel 和 React的关系 7. hello-react案例 步骤 8. react组件化开发 先通过类的方式来封装组件： 9. 数据依赖组件化问题一：那么数据定义在哪儿？ 10. 数据修改 难点：bind绑定 this的指向问题（严格模式下） 11. 事件绑定组件化问题二：事件绑定的this指向？ 12. hello-react案例重构 数据：state 修改数据：this.setState({}) 提前绑定this 13. 电影列表的展示【demo】 14. 计数器【demo】","categories":[{"name":"React","slug":"React","permalink":"http://example.com/categories/React/"}],"tags":[],"keywords":[{"name":"React","slug":"React","permalink":"http://example.com/categories/React/"}]},{"title":"一文知TypeScript的核心","slug":"颠覆认知的『TypeScript』【TS深度学习】","date":"2024-03-20T14:00:41.000Z","updated":"2024-07-21T04:36:07.563Z","comments":true,"path":"2024/03/20/颠覆认知的『TypeScript』【TS深度学习】/","permalink":"http://example.com/2024/03/20/%E9%A2%A0%E8%A6%86%E8%AE%A4%E7%9F%A5%E7%9A%84%E3%80%8ETypeScript%E3%80%8F%E3%80%90TS%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%91/","excerpt":"","text":"TypeSript【官网】【READBOOK】https://www.bookstack.cn/read/wangdoc-typescript-tutorial/docs-d.ts.md ts是js的一个超集，解决js类型支持js: 动态类型ts:静态类型 代码执行的顺序是先编译在执行 发现错误更早 1.为什么要添加类型支持？ 2.优势有什么？ 3.全局安装npm i -g typescripttsc -v 4.简化运行ts的步骤 5.typescript常用类型 类型检查机制 5.1 类型注解 5.2 常用基础类型 5.3 原始类型 6.数组类型 7.类型别名 type关键字 123456// 类型别名type CustomArray = (number|string)[]let arr1:CustomArray = [1,2,&#x27;a&#x27;,3]let arr2:CustomArray = [1,4,&#x27;a&#x27;,3]console.log(arr1);console.log(arr2); 8.函数类型 9.可选参数 10.对象类型对象的类型其实就是在描述对象的结构 11.对象中的可选属性 12.接口【复用】 1234567891011121314151617181920212223// 接口interface IPerson&#123; name:string age:number sayhi():void&#125;let person_3:IPerson =&#123; name:&#x27;JACL&#x27;, age:11, sayhi()&#123;&#125;&#125;let person_4:IPerson =&#123; name:&#x27;JAC33L&#x27;, age:33, sayhi()&#123;&#125;&#125;console.log(person_3);console.log(person_4); 13.接口和类型别名 12345type num = number | stringlet a:num = 1let b:num = &#x27;asf&#x27;console.log(a);console.log(b); 14.接口继承复用 15.元组 16.类型推论 17.类型断言 18.字面量类型 19.枚举类型 20.字符串枚举 21.枚举特点 22.any类型 23.ypeof 24.TS高级类型24.1 class 25.类的实例方法 26.类的继承 27.类成员可见性 28.类型兼容性 29.对象兼容性 30.接口兼容性 31.函数兼容性 32.类型兼容性 33.交叉类型 34.交叉类型(&amp;)和接口继承(extends)的区别 35.泛型 36.简化调用泛型函数 37.泛型循环 38.添加约束 39.泛型的类型变量 40.泛型接口41.JS中的数组就是TS中的一个泛型接口 42.class配合泛型来使用 43.泛型工具类型43.1 partial 43.2 readonly 43.3 pick 43.4 record 44.索引签名类型 45.映射类型45.1 基于旧类型进行创建 45.2 基于对象创建 45.3 引查询类型 45.4 同时查询多个索引的类型 46.d.ts 类型声明文件 47.TS中的两种文件类型 48.类型声明文件的使用说明 49.使用已有的类型声明文件49.1 内置api 49.2 第三方库的类型声明 49.3 definitelyTyped 49.4 创建自己的声明文件 49.5 项目内共享类型 49.6 为已有js文件提供类型声明 50.【webpack】搭建一个基本的webpack4.x项目51.React支持TS","categories":[{"name":"TypeScript","slug":"TypeScript","permalink":"http://example.com/categories/TypeScript/"}],"tags":[],"keywords":[{"name":"TypeScript","slug":"TypeScript","permalink":"http://example.com/categories/TypeScript/"}]},{"title":"面试题【Record】第一回","slug":"面试题【Record】第一回","date":"2024-02-20T14:00:41.000Z","updated":"2024-07-22T02:40:51.345Z","comments":true,"path":"2024/02/20/面试题【Record】第一回/","permalink":"http://example.com/2024/02/20/%E9%9D%A2%E8%AF%95%E9%A2%98%E3%80%90Record%E3%80%91%E7%AC%AC%E4%B8%80%E5%9B%9E/","excerpt":"","text":"如何判断一个对象为空？为什么data是一个函数?v-if与v-show的区别？用法与本质上的区别v-for中的key是什么作用? diff算法的实现原理虚拟DOM的作用？真实DOM &amp; 通过移动原生控件在移动端显示出来 &amp; 桌面端的一些控件 &amp; VR设备 –做跨平台computed 和 methods的区别？展开运算符的用法？获取Vue创建的代理的原始对象？toRawwatch的基本用法，以及侦听选项？deep immediate vue事件绑定如何传递参数?如何传递event参数?v-for中的key有什么作用?什么是虚拟DOM?什么是计算属性?和method有什么区别?如何在Vue中侦听一个数据的改变?v-model的原理? 什么是双向绑定?v-model的本质是什么?如何手动实现v-model?v-moder加上lazy、number、trim修饰符有什么作用？什么是组件化开发?有什么作用?什么是Vue CLl，如何使用它创建Vue项目? 脚手架创建项目的流程？Vue中注册全局组件和局部组件有什么区别?","categories":[{"name":"Record","slug":"Record","permalink":"http://example.com/categories/Record/"}],"tags":[],"keywords":[{"name":"Record","slug":"Record","permalink":"http://example.com/categories/Record/"}]},{"title":"By计数器理解自定义事件【PRACTICE】","slug":"组件通信-理解自定义事件","date":"2023-02-23T14:00:41.000Z","updated":"2024-07-22T16:05:46.800Z","comments":true,"path":"2023/02/23/组件通信-理解自定义事件/","permalink":"http://example.com/2023/02/23/%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1-%E7%90%86%E8%A7%A3%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BA%8B%E4%BB%B6/","excerpt":"","text":"App.vue 123456789101112131415161718192021222324252627282930313233343536&lt;script&gt;import SubCounter from &quot;./SubCounter.vue&quot;;import AddCounter from &quot;./AddCounter.vue&quot;;export default &#123; name: &quot;App&quot;, components:&#123; SubCounter, AddCounter &#125;, data()&#123; return &#123; counter: 0, &#125; &#125;, methods:&#123; btnClick(count)&#123; this.counter += count &#125;, subBtnClick(count)&#123; this.counter -= count &#125; &#125;&#125;&lt;/script&gt;&lt;template&gt; &lt;div class=&quot;app&quot;&gt; &lt;h2&gt;小小计数器：&#123;&#123;counter&#125;&#125;&lt;/h2&gt; &lt;sub-counter @sub=&quot;subBtnClick&quot;&gt;&lt;/sub-counter&gt; &lt;add-counter @add=&quot;btnClick&quot;&gt;&lt;/add-counter&gt; &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt;&lt;/style&gt; AddCounter.vue 12345678910111213141516171819202122&lt;script&gt;export default &#123; name: &quot;AddCounter&quot;, methods:&#123; addClick(count)&#123; this.$emit(&#x27;add&#x27;,count) &#125; &#125;&#125;&lt;/script&gt;&lt;template&gt; &lt;div class=&quot;add&quot;&gt; &lt;button @click=&quot;addClick(1)&quot;&gt;+1&lt;/button&gt; &lt;button @click=&quot;addClick(5)&quot;&gt;+5&lt;/button&gt; &lt;button @click=&quot;addClick(1000)&quot;&gt;+1000&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt;&lt;/style&gt; SubCounter.vue 12345678910111213141516171819202122&lt;script&gt;export default &#123; name: &quot;AddCounter&quot;, methods:&#123; addClick(count)&#123; this.$emit(&#x27;add&#x27;,count) &#125; &#125;&#125;&lt;/script&gt;&lt;template&gt; &lt;div class=&quot;add&quot;&gt; &lt;button @click=&quot;addClick(1)&quot;&gt;+1&lt;/button&gt; &lt;button @click=&quot;addClick(5)&quot;&gt;+5&lt;/button&gt; &lt;button @click=&quot;addClick(1000)&quot;&gt;+1000&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt;&lt;/style&gt; 呈现：","categories":[{"name":"vue","slug":"vue","permalink":"http://example.com/categories/vue/"}],"tags":[],"keywords":[{"name":"vue","slug":"vue","permalink":"http://example.com/categories/vue/"}]},{"title":"简单梳理一下vue3【BASIC】","slug":"Vue3【进阶】","date":"2023-02-22T14:00:41.000Z","updated":"2024-07-22T15:27:56.747Z","comments":true,"path":"2023/02/22/Vue3【进阶】/","permalink":"http://example.com/2023/02/22/Vue3%E3%80%90%E8%BF%9B%E9%98%B6%E3%80%91/","excerpt":"","text":"1. 简介https://cn.vuejs.org/guide/introduction.html 2. 创建vue3工程【详细看vue创建前端项目的那篇】2.1【基于 vue-cli创建】基本和vue-cli的过程类似，只是选择的时候用vue3创建 2.2【基于vite创建】【推荐】【官网】https://vitejs.cn/ 【可以先去学一下webpack】vite 是新一代前端构建工具，官网地址:https://vitejs.cn，vite的优势如下: 轻量快速的热重载(HMR)，能实现极速的服务启动。 对 Typescript、Jsx、css 等支持开箱即用。 真正的按需编译、不再等待整个应用编译完成。 2.3 步骤 【https://cn.vitejs.dev/guide/】 npm create vue@latestpnpm create vue 你还可以通过附加的命令行选项直接指定项目名称和你想要使用的模板。例如，要构建一个 Vite + Vue 项目，运行:bash 1234567891011# npm 7+, extra double-dash is needed:npm create vite@latest my-vue-app -- --template vue# yarnyarn create vite my-vue-app --template vue# pnpmpnpm create vite my-vue-app --template vue# bunbun create vite my-vue-app --template vue 查看 create-vite 以获取每个模板的更多细节：vanilla，vanilla-ts, vue, vue-ts，react，react-ts，react-swc，react-swc-ts，preact，preact-ts，lit，lit-ts，svelte，svelte-ts，solid，solid-ts，qwik，qwik-ts。 2.4 命令行创建 3. 小结 4. VUE3核心语法【optionsAPI】和【compositionAPI】-&gt;【vue2】和【vue3】 Vue2 的 API 设计是 options(配置)风格的。 Vue3 的API 设计是 Composition(组合)风格的。 5. 拉开序幕的【setup】 新的配置项 setup语法糖出现时机在beforecreated之前 setup的返回值也是一个渲染函数 【面试题】setup和vue2中的data、method有什么区别？ 可以同时存在 setup执行的比data的早（data可以拿到setup中的值，但是反过来拿不到） 6. Setup语法糖之前的写法缺点是：每次都要返回数据和方法语法糖写法不需要返回，setup自动给你返回；只关注数据和方法因为最新的语法糖省去了name,则利用插件npm i vite-plugin-vue-setup-extend -D来命名一般其实和文件名一样可以不写 7. ref_可以实现【基本类型】响应式数据 【让数据动起来】vue2-&gt;都放在data中，就是响应式了vue3-&gt;ref 和 reative 此ref不是vue2中的ref 什么时候需要value和什么时候不需要value是需要注意的点 模块中不需要。JS中操作需要！ 作用： 8. reactive_创建【对象类型】【只能定义】响应式数据 9. ref_可以实现【对象类型】响应式数据 【让数据动起来】需要注意的是： 使用ref的时候必须加上.value去拿到值 ref的实现也是基于reactive实现的（底层逻辑） ref既可以定义基本类型也可以对象类型 10.【ref对比reactive】 可以用volar插件【目前是官方vue插件】自动添加.value 在设置中进行设置-勾上即可 11. toRefs 和 toRef 1234567891011121314151617181920212223242526272829&lt;template&gt; &lt;h1&gt;hello&lt;/h1&gt; &lt;h1&gt;姓名：&#123;&#123; name &#125;&#125;&lt;/h1&gt; &lt;h1&gt;年龄：&#123;&#123; age&#125;&#125;&lt;/h1&gt; &lt;button @click=&quot;changeName&quot;&gt;修改名字&lt;/button&gt; &lt;button @click=&quot;changeAge&quot;&gt;修改年龄&lt;/button&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot;&gt; import &#123; reactive,toRefs &#125; from &#x27;vue&#x27;; let person = reactive(&#123; name: &#x27;John&#x27;, age:22 &#125;) // toRefs 就是将reactive中的数据都取出来 数据还是具备响应式 let &#123;name, age&#125; = toRefs(person) const changeName = () =&gt;&#123; name.value = &#x27;lisi&#x27; &#125; const changeAge = () =&gt;&#123; age.value += 1 &#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 12. computed属性【是有缓存的与vue2一致】 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;template&gt; 姓：&lt;input type=&quot;text&quot; v-model=&quot;names&quot;&gt;&lt;br&gt; 名：&lt;input type=&quot;text&quot; v-model=&quot;ming&quot;&gt;&lt;br&gt; 姓名: &lt;h1&gt;&#123;&#123;fullname&#125;&#125;&lt;/h1&gt; &lt;button @click=&quot;changeFullname&quot;&gt;修改全名&lt;/button&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot;&gt;import &#123; ref ,computed&#125; from &#x27;vue&#x27;;let names= ref(&#x27;张三&#x27;)let ming = ref(&#x27;ming&#x27;)// 只读的不可修改的// let fullname =computed(()=&gt;&#123;// return names.value + ming.value.slice(0,1).toUpperCase() + ming.value.slice(1)// &#125;)// 这样可读可写let fullname =computed(&#123; get()&#123; return names.value + ming.value.slice(0,1).toUpperCase() + ming.value.slice(1) &#125;, set(vals)&#123; const x = vals.split(&#x27;-&#x27;) names.value = x[0] ming.value = x[1] console.log(x); &#125;,&#125;)let changeFullname = ()=&gt;&#123; console.log(fullname.value); fullname.value = &#x27;li-si&#x27; &#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 13. watch监视数据的变化 13.1 情况一【常用】：监视 ref 定义的【基本类型】数据:直接写数据名即可，监视的是其 value 值的改变。 123456789101112131415161718192021222324252627&lt;template&gt; &lt;div class=&quot;person&quot;&gt; &lt;h1&gt;情况一&lt;/h1&gt; &lt;h1&gt;sum：&#123;&#123; sum &#125;&#125;&lt;/h1&gt; &lt;button @click=&quot;changeName&quot;&gt;点我sum+1&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot;&gt;import &#123;ref,watch&#125; from &#x27;vue&#x27;let sum = ref(100)let changeName = ()=&gt;&#123; sum.value += 100&#125;const stopWatch = watch(sum,(newValue,oldValue)=&gt;&#123; console.log(newValue,oldValue); if(newValue&gt;1000)&#123; stopWatch() &#125;&#125;)&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 13.2 情况二： 1234567891011121314151617181920212223242526272829303132333435363738&lt;template&gt; &lt;div class=&quot;person&quot;&gt; &lt;h1&gt;姓名：&#123;&#123;person.name &#125;&#125;&lt;/h1&gt; &lt;h2&gt;年龄：&#123;&#123;person.age&#125;&#125;&lt;/h2&gt; &lt;button @click=&quot;changename&quot;&gt;修改年龄&lt;/button&gt; &lt;button @click=&quot;changeperson&quot;&gt;修改person&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot; setup&gt;import &#123;ref,watch&#125; from &#x27;vue&#x27; let person = ref(&#123; name:&quot;zhangsan&quot;, age:22, &#125;) const changename = () =&gt;&#123; person.value.age += 1; &#125; const changeperson = () =&gt;&#123; // 如果是recative 就要用object.assgin person.value = &#123;name:&quot;zha33ngsan&quot;, age:2342&#125; &#125; watch(person,(newValue,oldValue)=&gt;&#123; console.log(newValue,oldValue); &#125;,&#123;deep:true,immediate:true&#125;)&lt;/script&gt;&lt;style&gt; .person&#123; background-color: skyblue; box-shadow: 0 0 10px; border-radius: 10px; padding: 10px; &#125;&lt;/style&gt; 13.3 情况三： 1234567891011121314151617181920212223242526272829303132333435363738&lt;template&gt; &lt;div class=&quot;person&quot;&gt; &lt;h1&gt;姓名：&#123;&#123;person.name &#125;&#125;&lt;/h1&gt; &lt;h2&gt;年龄：&#123;&#123;person.age&#125;&#125;&lt;/h2&gt; &lt;button @click=&quot;changename&quot;&gt;修改年龄&lt;/button&gt; &lt;button @click=&quot;changeperson&quot;&gt;修改person&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot; setup&gt;import &#123;ref,watch,reactive&#125; from &#x27;vue&#x27; let person = reactive(&#123; name:&quot;zhangsan&quot;, age:22, &#125;) const changename = () =&gt;&#123; person.age += 1; &#125; const changeperson = () =&gt;&#123; // 如果是recative 就要用object.assgin Object.assign(person,&#123;name:&quot;zha33ngsan&quot;, age:2342&#125;) &#125; watch(person,(newValue,oldValue)=&gt;&#123; console.log(newValue,oldValue); &#125;)&lt;/script&gt;&lt;style&gt; .person&#123; background-color: skyblue; box-shadow: 0 0 10px; border-radius: 10px; padding: 10px; &#125;&lt;/style&gt; 13.4 情况四【常用】【函数式】: 结论: 监视的要是对象里面的属性，最好写成函数，注意：若是监视的是地址值，需要关注对象内部。需要开启手动深度监视 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;template&gt; &lt;div class=&quot;person&quot;&gt; &lt;h1&gt;姓名：&#123;&#123;person.name &#125;&#125;&lt;/h1&gt; &lt;h2&gt;年龄：&#123;&#123;person.age&#125;&#125;&lt;/h2&gt; &lt;h2&gt;汽车：&#123;&#123;person.car.car1&#125;&#125;-&#123;&#123; person.car.car2 &#125;&#125;&lt;/h2&gt; &lt;button @click=&quot;changename&quot;&gt;修改年龄&lt;/button&gt; &lt;button @click=&quot;changeperson&quot;&gt;修改person&lt;/button&gt; &lt;button @click=&quot;changeCar1&quot;&gt;修改car1&lt;/button&gt; &lt;button @click=&quot;changeCar2&quot;&gt;修改car2&lt;/button&gt; &lt;button @click=&quot;changeAll&quot;&gt;修改全部&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot; setup&gt;import &#123;ref,watch,reactive&#125; from &#x27;vue&#x27; let person = reactive(&#123; name:&quot;zhangsan&quot;, age:22, car:&#123; car1:&#x27;hello1&#x27;, car2:&#x27;hello2&#x27; &#125; &#125;) const changename = () =&gt;&#123; person.age += 1; &#125; const changeperson = () =&gt;&#123; // 如果是recative 就要用object.assgin Object.assign(person,&#123;name:&quot;zha33ngsan&quot;, age:2342&#125;) &#125; const changeCar1 = ()=&gt;&#123; person.car.car1 = &#x27;world1&#x27; &#125; const changeCar2 = ()=&gt;&#123; person.car.car2 = &#x27;world2&#x27; &#125; const changeAll = ()=&gt;&#123; person.car = &#123;car1:&#x27;hello221&#x27;, car2:&#x27;hello241&#x27;&#125; &#125; watch(()=&gt;&#123;return person.age&#125;,(newValue,oldValue)=&gt;&#123; console.log(newValue,oldValue); &#125;) watch(()=&gt;person.car,(newValue,oldValue)=&gt;&#123; console.log(newValue,oldValue); &#125;,&#123;deep:true&#125;)&lt;/script&gt;&lt;style&gt; .person&#123; background-color: skyblue; box-shadow: 0 0 10px; border-radius: 10px; padding: 10px; &#125;&lt;/style&gt; 13.5 情况五:监视上述的多个数据【多个函数】 123watch([()=&gt;person.name,()=&gt;person.car.car1],(newValue,oldValue)=&gt;&#123; console.log(newValue,oldValue);&#125;,&#123;deep:true&#125;) 【多写项目-练习】 14. watchEffect) 15. 标签中ref属性 16. 回顾TS中的接口_泛型_自定义类型 17. Props的使用vue2【父子之间的通信】vue3通信注意点：【区别一下：的绑定和 ref的区别】【父子之间的传值的多种方式】【注意：宏函数不用引入，例如defineProps】 18. 理解生命周期【组件的一生】概念: vue 组件实例在创建时要经历一系列的初始化步骤，在此过程中 vue 会在合适的时机，调用特定的函数，从而让开发者有机会在特定阶段运行自己的代码，这些特定的函数统称为:生命周期钩子创建、挂载、更新、销毁【每个时期都调用特定的函数】created 、 mounted 、updated 、destoyed叫法：生命周期、生命周期函数、生命周期钩子。 18.1 vue2的生命周期创建、（前与后）（beforeCreate|Created）挂载、（前与后）（beforeMount|Mounted)更新、（前与后）（beforeUpdate|updated)销毁、（前与后）（beforeDestory|destoryed) 18.2 vue3的生命周期创建、setup —————————-&gt; （前与后）（beforeCreate|Created）挂载、onBeforeMount|onMounted—&gt;（前与后）（beforeMount|Mounted)更新、onBeforeUpdate|onUpdated—&gt;（前与后）（beforeUpdate|updated)卸载、onBeforeUnmount|onUnmounted—-&gt;（前与后）（beforeDestory|destoryed) 19. 自定义hooks【mixin】【重】 20【….】. 路由 20.1 两个注意点路由组件：pages&#x2F;views一般组件：components 20.2 to的两种写法 20.3 路由器工作模式【history 和 hash模式】 20.4 命名路由 20.5 嵌套路由 20.6 路由_query参数 20.7 路由_params参数 必须为name 参数如果可传可不传则添加？在占位的地方 参数不能为数组和对象 21. 路由的Props配置 【注意】 一般组件和路由组件传参的区别 22. 路由的_replace属性 push【默认】 replace【替换】 23.【编程式导航】 出了routerlink进行跳转还有编程式路由导航 什么时候进行编程式导航 需要再某个条件下跳转 24. 路由重定向 25. Pinia【对比VUE2中vuex】【集中式状态数据管理】【redux vuex pinia】是vue的最新的状态管理工具，是vuex的替代品 26. 手动添加pinia官网：https://pinia.vuejs.org/zh/introduction.html 使用vite创建一个新的vue3项目 安装pinia到项目中 用vite安装时注意node的版本 26.1 案例lovetalk.vue 1234567891011121314151617181920212223242526272829303132333435363738&lt;template&gt; &lt;div class=&quot;lovetalk&quot;&gt; &lt;button @click=&quot;getLoveTalk&quot;&gt;hello&lt;/button&gt; &lt;ul&gt; &lt;li v-for=&quot;item in newsList&quot; :key=&quot;item.id&quot;&gt;&#123;&#123; item.title &#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot; setup&gt;import &#123; reactive &#125; from &#x27;vue&#x27;;import axios from &#x27;axios&#x27;;import &#123; nanoid &#125; from &#x27;nanoid&#x27;;const newsList = reactive([ &#123; id: &#x27;12423421&#x27;, title: &#x27;hel123&#x27; &#125;, &#123; id: &#x27;1224231&#x27;, title: &#x27;h424el123&#x27; &#125;, &#123; id: &#x27;1242341&#x27;, title: &#x27;he4243l123&#x27; &#125;,]);async function getLoveTalk() &#123; // 下面的写法：连续解构赋值 + 重命名 let &#123; data: &#123; content:title &#125;, &#125; = await axios.get(&#x27;https://api.uomg.com/api/rand.qinghua?format=json&#x27;); // nanoid 可以随机生成ID let obj = &#123; id: nanoid(),title&#125;; console.log(obj); newsList.unshift(obj);&#125;&lt;/script&gt;&lt;style&gt;.lovetalk &#123; background-color: skyblue; box-shadow: 0 0 10px; border: 1px solid black;&#125;&lt;/style&gt; count.vue 1234567891011121314151617181920212223242526272829303132&lt;template&gt; &lt;div class=&quot;count&quot;&gt; &lt;h2&gt;当前求和为：&#123;&#123;sum&#125;&#125;&lt;/h2&gt; &lt;select v-model.number=&quot;n&quot;&gt; &lt;option value=&quot;1&quot;&gt;1&lt;/option&gt; &lt;option value=&quot;2&quot;&gt;2&lt;/option&gt; &lt;option value=&quot;3&quot;&gt;3&lt;/option&gt; &lt;/select&gt; &lt;button @click=&quot;add&quot;&gt;加&lt;/button&gt; &lt;button @click=&quot;minus&quot;&gt;减 &lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot;&gt;import &#123;ref&#125; from &#x27;vue&#x27;let sum = ref(1)let n = ref(1)function add()&#123; sum.value += n.value&#125;function minus()&#123; sum.value -= n.value&#125;&lt;/script&gt;&lt;style&gt;.count &#123; background-color: skyblue; box-shadow: 0 0 10px; border: 1px solid black;&#125;&lt;/style&gt; 【注意】：引入了axios和nanoid【随机生成id】 26.2 搭建pinia环境npm i pinia 26.3 存取读取数据 27. 修改数据的三种方式 28. storeToRefs【只关注store数据】【对数据进行解构操作】 29. getters对数据的加工 30. $subscribe 31. store的组合式写法【推荐】 32. 组件通信_方式1_props 【父子】 33. 组件通信_方式2_自定义事件【子传父】 34. 组件通信_方式3_mitt【任意组件通信】 pubsub $bus mitt 35. 组件通信_方式4_v-model【通常用于表单】作用在组件和html的方式【底层】 36. 组件通信_方式5_$atters【祖孙之间通信】【打扰了中间人】 37. 组件通信_方式6_$refs-$parent【父-&gt;子|子-&gt;父】 38. 组件通信_方式7_provide_inject【提供-注入】【向后代之间通信】【零打扰】 39. 插槽39.1 默认插槽 39.2 具名插槽【template 中 v-solt &amp; #】【重】【动态的摆放】可以用【#s1 、#s2代替v-slot】 39.3 作用域插槽 40. 总结 41. 其他API41. shallowRef 和 shallowReactive 41.2 readonly 和 shallowReadonly 41.3 roRaw 和 markRow 41.4 customRef 41.5 Teleport【转移】 41.6 Suspense 41.7 全局api到应用对象 41.8 其他【非兼容性改变】 41.9 面试题：vue3相比vue2做了哪些改变?https://v3-migration.vuejs.org/zh/breaking-changes/","categories":[{"name":"vue","slug":"vue","permalink":"http://example.com/categories/vue/"}],"tags":[],"keywords":[{"name":"vue","slug":"vue","permalink":"http://example.com/categories/vue/"}]},{"title":"Vue09-项目中的应用-组件通信【基本】","slug":"Vue09-项目中的应用-组件通信【基本】","date":"2023-02-12T14:00:41.000Z","updated":"2024-07-24T09:09:02.506Z","comments":true,"path":"2023/02/12/Vue09-项目中的应用-组件通信【基本】/","permalink":"http://example.com/2023/02/12/Vue09-%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8-%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1%E3%80%90%E5%9F%BA%E6%9C%AC%E3%80%91/","excerpt":"","text":"","categories":[{"name":"vue","slug":"vue","permalink":"http://example.com/categories/vue/"}],"tags":[],"keywords":[{"name":"vue","slug":"vue","permalink":"http://example.com/categories/vue/"}]},{"title":"Vue08-项目中的应用-组件嵌套","slug":"Vue08-项目中的应用-组件嵌套","date":"2023-02-10T14:00:41.000Z","updated":"2024-07-24T09:11:07.052Z","comments":true,"path":"2023/02/10/Vue08-项目中的应用-组件嵌套/","permalink":"http://example.com/2023/02/10/Vue08-%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8-%E7%BB%84%E4%BB%B6%E5%B5%8C%E5%A5%97/","excerpt":"","text":"","categories":[{"name":"vue","slug":"vue","permalink":"http://example.com/categories/vue/"}],"tags":[],"keywords":[{"name":"vue","slug":"vue","permalink":"http://example.com/categories/vue/"}]},{"title":"Vue07-Vue-Cli脚手架开发【基于两种不同的方式】","slug":"Vue07-Vue-Cli脚手架开发【基于两种不同的方式】","date":"2023-02-08T14:00:41.000Z","updated":"2024-07-24T09:09:29.667Z","comments":true,"path":"2023/02/08/Vue07-Vue-Cli脚手架开发【基于两种不同的方式】/","permalink":"http://example.com/2023/02/08/Vue07-Vue-Cli%E8%84%9A%E6%89%8B%E6%9E%B6%E5%BC%80%E5%8F%91%E3%80%90%E5%9F%BA%E4%BA%8E%E4%B8%A4%E7%A7%8D%E4%B8%8D%E5%90%8C%E7%9A%84%E6%96%B9%E5%BC%8F%E3%80%91/","excerpt":"","text":"","categories":[{"name":"vue","slug":"vue","permalink":"http://example.com/categories/vue/"}],"tags":[],"keywords":[{"name":"vue","slug":"vue","permalink":"http://example.com/categories/vue/"}]},{"title":"Vue06-组件化开发-全局组件-局部组件","slug":"Vue06-组件化开发-全局组件-局部组件","date":"2023-02-05T14:00:41.000Z","updated":"2024-07-24T09:09:51.362Z","comments":true,"path":"2023/02/05/Vue06-组件化开发-全局组件-局部组件/","permalink":"http://example.com/2023/02/05/Vue06-%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91-%E5%85%A8%E5%B1%80%E7%BB%84%E4%BB%B6-%E5%B1%80%E9%83%A8%E7%BB%84%E4%BB%B6/","excerpt":"","text":"","categories":[{"name":"vue","slug":"vue","permalink":"http://example.com/categories/vue/"}],"tags":[],"keywords":[{"name":"vue","slug":"vue","permalink":"http://example.com/categories/vue/"}]},{"title":"Vue05-双向数据绑定v-model","slug":"Vue05-双向数据绑定v-model","date":"2023-02-02T14:00:41.000Z","updated":"2024-07-24T09:10:09.075Z","comments":true,"path":"2023/02/02/Vue05-双向数据绑定v-model/","permalink":"http://example.com/2023/02/02/Vue05-%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9Av-model/","excerpt":"","text":"","categories":[{"name":"vue","slug":"vue","permalink":"http://example.com/categories/vue/"}],"tags":[],"keywords":[{"name":"vue","slug":"vue","permalink":"http://example.com/categories/vue/"}]},{"title":"Vue04-阶段性案例-排他思想","slug":"Vue04-阶段性案例-排他思想","date":"2023-01-29T14:00:41.000Z","updated":"2024-07-24T09:10:21.827Z","comments":true,"path":"2023/01/29/Vue04-阶段性案例-排他思想/","permalink":"http://example.com/2023/01/29/Vue04-%E9%98%B6%E6%AE%B5%E6%80%A7%E6%A1%88%E4%BE%8B-%E6%8E%92%E4%BB%96%E6%80%9D%E6%83%B3/","excerpt":"","text":"","categories":[{"name":"vue","slug":"vue","permalink":"http://example.com/categories/vue/"}],"tags":[],"keywords":[{"name":"vue","slug":"vue","permalink":"http://example.com/categories/vue/"}]},{"title":"Vue03-computedApi-watchApi","slug":"Vue03-computedApi-watchApi","date":"2023-01-27T14:00:41.000Z","updated":"2024-07-24T09:10:39.527Z","comments":true,"path":"2023/01/27/Vue03-computedApi-watchApi/","permalink":"http://example.com/2023/01/27/Vue03-computedApi-watchApi/","excerpt":"","text":"","categories":[{"name":"vue","slug":"vue","permalink":"http://example.com/categories/vue/"}],"tags":[],"keywords":[{"name":"vue","slug":"vue","permalink":"http://example.com/categories/vue/"}]},{"title":"Vue02-事件绑定-条件渲染-列表渲染-computed-watch侦听","slug":"Vue02-事件绑定-条件渲染-列表渲染-computed-watch侦听","date":"2023-01-23T14:00:41.000Z","updated":"2024-07-24T09:08:47.529Z","comments":true,"path":"2023/01/23/Vue02-事件绑定-条件渲染-列表渲染-computed-watch侦听/","permalink":"http://example.com/2023/01/23/Vue02-%E4%BA%8B%E4%BB%B6%E7%BB%91%E5%AE%9A-%E6%9D%A1%E4%BB%B6%E6%B8%B2%E6%9F%93-%E5%88%97%E8%A1%A8%E6%B8%B2%E6%9F%93-computed-watch%E4%BE%A6%E5%90%AC/","excerpt":"","text":"v-on事件绑定的写法参数传递v-on的修饰符","categories":[{"name":"vue","slug":"vue","permalink":"http://example.com/categories/vue/"}],"tags":[],"keywords":[{"name":"vue","slug":"vue","permalink":"http://example.com/categories/vue/"}]},{"title":"Vue01-基础语法-模板语法-基本指令-v-bind","slug":"Vue01-基础语法-模板语法-基本指令-v-bind","date":"2023-01-22T14:00:41.000Z","updated":"2024-07-24T09:08:47.524Z","comments":true,"path":"2023/01/22/Vue01-基础语法-模板语法-基本指令-v-bind/","permalink":"http://example.com/2023/01/22/Vue01-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95-%E6%A8%A1%E6%9D%BF%E8%AF%AD%E6%B3%95-%E5%9F%BA%E6%9C%AC%E6%8C%87%E4%BB%A4-v-bind/","excerpt":"","text":"Vue的引入方法 CDN引入 本地引入 Vue动态的数据展示 声明式编程 面试题：声明式编程和命令式编程的区别？ 原生DOM都是采用的命令式编程，操作页面的元素都要获取该元素的DOM。然而在Vue中不需要操作原生的DOM，直接在data中声明数据即可。 不直接操作DOM,将一些数据直接渲染到页面上 Vue展示列表数据 数组如何渲染 1234567891011121314151617181920&lt;script&gt; let title = &quot;hello world&quot; const app = Vue.createApp(&#123; template:` &lt;h1&gt;&#123;&#123; name &#125;&#125;&lt;/h1&gt; &lt;ul&gt; &lt;li v-for=&quot;(item,index) in name&quot;&gt;&#123;&#123;item&#125;&#125;&lt;/li&gt; &lt;/ul&gt; `, data:function () &#123; return &#123; title:title, name: [&quot;张三&quot;, &quot;李四&quot;, &quot;王五&quot;], &#125;; &#125; &#125;) console.log(app) // 挂载 app.mount(&quot;#app&quot;) &lt;/script&gt; Vue实现计数器【经典案例】Option-api data 面试题：为什么data是一个函数? methods Mystache双括号语法【大胡子语法】Vue的指令 v-once v-text v-html v-pre v-cloak v-memo v-bind指令v-bind绑定基本属性 需要动态的改变页面的属性，通过v-bind来动态的绑定 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src=&quot;./lib/Vue.js&quot;&gt;&lt;/script&gt; &lt;style&gt; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;h2&gt;你好&lt;/h2&gt;&lt;!-- 但是，除了内容需要动态来决定外，某些属性我们也希望动态来绑定。--&gt; &lt;div id=&quot;app&quot;&gt; &lt;div&gt; &lt;h1&gt;&#123;&#123;name&#125;&#125;&lt;/h1&gt; &lt;img :src=&quot;url&quot; alt=&quot;&quot;&gt;&lt;!-- 有很多的，比如图片的链接src、网站的链接href、动态绑定一些类、样式等等 --&gt; &lt;a :href=&quot;href&quot;&gt;百度一下&lt;/a&gt; &lt;/div&gt; &lt;button @click=&quot;update&quot;&gt;改变&lt;/button&gt; &lt;/div&gt; &lt;script&gt; const app = Vue.createApp(&#123; data() &#123; return &#123; name:&quot;chenyi&quot;, url:&quot;https://www.neu.edu.cn/images/dangdaihuinew.jpg&quot;, href:&quot;https://www.neu.edu.cn/&quot;, url2:&quot;https://www.neu.edu.cn/images/2696de7a-6d24-4272-a7b2-7466a35d17d4.jpg&quot;, &#125; &#125;, methods:&#123; update:function ()&#123; this.href=&quot;https://cysir.icu&quot;; this.url = this.url === this.url2 ? this.url : this.url2 &#125; &#125; &#125;); console.log(app); // 挂载 app.mount(&#x27;#app&#x27;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; v-bind绑定class属性 需要动态的改变页面的样式，通过v-bind来动态的绑定样式。【不同的写法】 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src=&quot;./lib/Vue.js&quot;&gt;&lt;/script&gt; &lt;style&gt; .active&#123; color:red; &#125; .demo&#123; font-size: 30px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;h1 &gt;hello world&lt;/h1&gt;&lt;!-- &lt;button :class=&quot;isActive ? &#x27;active&#x27;:&#x27;&#x27; &quot; @click=&quot;btnClick&quot;&gt;按钮&lt;/button&gt;--&gt;&lt;!-- 动态class可以写对象语法--&gt;&lt;!-- 我们可以传给:class (v-bind:class 的简写)一个对象，以动态地切换 class--&gt;&lt;!-- &lt;button :class=&quot;&#123;active:isActive&#125;&quot; @click=&quot;btnClick&quot; &gt;按钮&lt;/button&gt;--&gt;&lt;!-- 对象语法的多个键值对--&gt;&lt;!-- &lt;button :class=&quot;&#123;active:isActive,why:true&#125;&quot; @click=&quot;btnClick&quot; &gt;按钮&lt;/button&gt;--&gt;&lt;!-- 动态绑定的class是可以和普通的class同时的使用 ~!!!!!!!!!!!!!!!!!!--&gt; &lt;button class=&quot;demo&quot; :class=&quot;getDynamicClass()&quot; @click=&quot;btnClick&quot; &gt;按钮&lt;/button&gt; &lt;h1 :class=&quot;[&#x27;abc&#x27;,&#x27;def&#x27;]&quot;&gt;hello&lt;/h1&gt; &lt;h1 :class=&quot;[&#x27;abc&#x27;,className,getDynamicClass()]&quot;&gt;hello&lt;/h1&gt; &lt;/div&gt; &lt;script&gt; const app = Vue.createApp(&#123; data() &#123; return &#123; isActive:false, className:&#x27;why&#x27; &#125; &#125;, methods:&#123; btnClick:function ()&#123; this.isActive = !this.isActive &#125;, getDynamicClass:function ()&#123; return &#123;active:this.isActive,why:true&#125; &#125; &#125; &#125;); app.mount(&#x27;#app&#x27;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; v-bind绑定style属性1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src=&quot;./lib/Vue.js&quot;&gt;&lt;/script&gt; &lt;style&gt; .active&#123; color:red; &#125; .demo&#123; font-size: 30px; font-family: &quot;Agency FB&quot;; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt;&lt;!-- 2.1.动态绑定style，在后面跟上:对象类型--&gt;&lt;!-- 单引号 或者 驼峰--&gt;&lt;!-- CSS property 名可以用驼峰式(camelCase)或短横线分隔(kebab-case， 记得用引号括起来)来命名;--&gt; &lt;h1 :style=&quot;&#123;color:fontColor,fontSize:fontSize&#125;&quot;&gt;hello world&lt;/h1&gt;&lt;!-- 动态的绑定属性，这个属性是一个对象--&gt; &lt;h2 :style=&quot;objStyle&quot;&gt;chenyi&lt;/h2&gt;&lt;!-- 动态的绑定属性，这个属性是一个数组--&gt; &lt;h2 :style=&quot;[objStyle,&#123;fontFamily:&#x27;Agency FB&#x27;&#125;]&quot;&gt;呵呵哈哈哈&lt;/h2&gt; &lt;/div&gt; &lt;script&gt; const app = Vue.createApp(&#123; data() &#123; return &#123; fontColor:&quot;green&quot;, fontSize:&#x27;60px&#x27;, objStyle:&#123; color:&#x27;green&#x27;, fontSize: &#x27;100px&#x27; &#125; &#125; &#125;, methods:&#123; btnClick:function ()&#123; this.isActive = !this.isActive &#125;, getDynamicClass:function ()&#123; return &#123;active:this.isActive,why:true&#125; &#125; &#125; &#125;); app.mount(&#x27;#app&#x27;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; v-bind绑定属性名v-bind直接绑定对象 一般在组件传值的时候可以用","categories":[{"name":"vue","slug":"vue","permalink":"http://example.com/categories/vue/"}],"tags":[],"keywords":[{"name":"vue","slug":"vue","permalink":"http://example.com/categories/vue/"}]},{"title":"开启前端之旅","slug":"前端之旅","date":"2020-09-20T14:00:41.000Z","updated":"2024-07-23T05:12:17.523Z","comments":true,"path":"2020/09/20/前端之旅/","permalink":"http://example.com/2020/09/20/%E5%89%8D%E7%AB%AF%E4%B9%8B%E6%97%85/","excerpt":"","text":"每日必看: https://interview.poetries.top/","categories":[{"name":"tool","slug":"tool","permalink":"http://example.com/categories/tool/"}],"tags":[],"keywords":[{"name":"tool","slug":"tool","permalink":"http://example.com/categories/tool/"}]}]}