{"meta":{"title":"大白话说前端，多读源码多实践，勤于思考善领悟","subtitle":"","description":"我相信一万小时定律","author":"er dong yi","url":"http://example.com"},"pages":[],"posts":[{"title":"v-for指令中key&虚拟dom&diff算法【QUESTION】","slug":"v-for中的key有什么作用什么是虚拟DOM","date":"2024-07-22T14:00:41.000Z","updated":"2024-07-22T12:19:19.869Z","comments":true,"path":"2024/07/22/v-for中的key有什么作用什么是虚拟DOM/","permalink":"http://example.com/2024/07/22/v-for%E4%B8%AD%E7%9A%84key%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%E4%BB%80%E4%B9%88%E6%98%AF%E8%99%9A%E6%8B%9FDOM/","excerpt":"","text":"1.认识一下v-for的作用简单说，vue可以使用v-for来遍历元素 2.重点说一下key属性那么在属性中，绑定key和不绑定key的一个区别是什么？ key属性主要用在Vue的虚拟DOM算法，在新I日nodes对比时辨识VNodes 如果不使用key，Vue会使用一种最大限度减少动态元素并且尽可能的尝试就地修改/复用相同类型元素的算法; 而使用key时，它会基于key的变化重新排列元素顺序，并且会移除/销毁key不存在的元素; 底层主要实现的是diff算法 有key或无key主要vnode是否进行复用的一个操作 有key可以提升浏览器渲染生成真实DOM的一个性能的","categories":[{"name":"vue","slug":"vue","permalink":"http://example.com/categories/vue/"}],"tags":[],"keywords":[{"name":"vue","slug":"vue","permalink":"http://example.com/categories/vue/"}]},{"title":"vue创建前端项目两种不同的方式","slug":"VUECLI的创建","date":"2024-07-21T14:00:41.000Z","updated":"2024-07-22T12:08:11.371Z","comments":true,"path":"2024/07/21/VUECLI的创建/","permalink":"http://example.com/2024/07/21/VUECLI%E7%9A%84%E5%88%9B%E5%BB%BA/","excerpt":"","text":"1.方式一【基于webpack构建】全局按照依赖包，通过vue create ‘xxx（项目名）’来创建具体步骤如下： 1.1 全局安装依赖包 (注意ode版本)npm install -g @vue/cli 1.2 创建一个项目1vue create project_demo 1.3 选择需要的版本或者手动选择特性 选择预设 选择特性 选择版本 选择配置是否单独放一个文件中 是否保存为一个预设 基于以上配置通过vue create命令基本创建完成。 目录介绍 2.方式二【基于vite构建】2.1 npm init vue@latest 1.安装一个本地工具，create-vue2.用create-vue创建一个vue项目 @latest 总是保持一个最新的版本 其他与webpack构建的基本是一致的。","categories":[{"name":"vue","slug":"vue","permalink":"http://example.com/categories/vue/"}],"tags":[],"keywords":[{"name":"vue","slug":"vue","permalink":"http://example.com/categories/vue/"}]},{"title":"JS_函数中this的指向多情况分析","slug":"JS01_函数中this的指向多情况分析","date":"2024-07-20T10:58:13.713Z","updated":"2024-07-22T02:47:10.399Z","comments":true,"path":"2024/07/20/JS01_函数中this的指向多情况分析/","permalink":"http://example.com/2024/07/20/JS01_%E5%87%BD%E6%95%B0%E4%B8%ADthis%E7%9A%84%E6%8C%87%E5%90%91%E5%A4%9A%E6%83%85%E5%86%B5%E5%88%86%E6%9E%90/","excerpt":"","text":"1.默认绑定默认绑定this都是指向的window全局对象 JS中只要定义了一个方法，那么该方法就会有this指向，然而在不同的情况this的指向也会有所不同 情况一：函数直接调用 情况二：通过对象调用 情况三：箭头函数调用 12345678910111213141516171819202122// 1.直接调用function foo() &#123; console.log(&#x27;this绑定规则一之默认绑定&#x27;); console.log(this)&#125;foo()// 2.函数定义在对象之后，但是独立调用var obj = &#123; name: &quot;John&quot;, bar:function ()&#123; console.log(&#x27;bar&#x27;,this) &#125;&#125;var bax = obj.barbax()// 3.高阶函数function test(fn)&#123; fn()&#125;test(obj.bar); 上面两种方式的调用this都是默认绑定，指向的window全局对象 补充：若是在严格模式”use strict”下，独立调用的函数的this指向是指向undefined 2.隐式绑定隐式绑定this指向的是某个对象发起的函数调用，指向这个对象本身 12345678// 也就是它的调用位置中，是通过某个对象发起的函数调用function foo() &#123; console.log(this)&#125;var x = &#123; bar:foo&#125;x.bar() this指向的是x这个对象本身。 3.new关键字使用new关键词时，会创建一个新的空对象，this指向这个空对象【简单解释】 12345678910111213function foo() &#123; console.log(this) this.name = &#x27;hello world&#x27;&#125; new foo()// foo()/*1.创建一个空对象2.将this指向这个空对象3.指向函数体中的代码4.没有显示返回的非空对象时，默认返回这个对象 */ 控制台打印结果为：foo {} 4.显示绑定apply、call、bind4.1 call函数可以执行call函数，强制this指向某一个对象，可以明确的告诉this绑定什么，直接了当 123456789101112var obj = &#123; name: &quot;John&quot;,&#125;function add() &#123; console.log(this)&#125;// obj.add = add// obj.add()// 执行函数，并且强制this就是obj对象 自己显示的明确告诉他绑定什么//执行函数，并且函数中的this指向obj对象add.call(obj)add.call(412) 4.2 apply函数apply函数主要与call的区别是传入的参数格式不同，都可以明白告诉this绑定什么 123456789101112131415161718192021/* 调用一起函数，同时绑定一个this */function foo(name,age,height)&#123; console.log(this) console.log(name,age,height)&#125;foo(&#x27;kobe&#x27;, 12, 1.98)/* 第一个参数：绑定this 第二个参数：传入额外的参数，以数组的形式 */foo.apply(&#x27;hello world&#x27;, [&#x27;kobe&#x27;, 12, 1.98]);/* 第一个参数：绑定this 参数列表：后续的参数是以多参数的一个形式的 */foo.call(&#x27;call&#x27;, &quot;zhangsan&quot;, 213, 2.07);// call 和 apply 第二个参数的传入的格式不一样 4.3 bind函数bind() 被调用时，这个新函数的 this 被指定为 bind() 的第一个参数，而其余参数将作为新函数的参数，供调用时进行使用 官方：Function.prototype.bind() Function 实例的 bind() 方法创建一个新函数，当调用该新函数时，它会调用原始函数并将其 this 关键字设置为给定的值，同时，还可以传入一系列指定的参数，这些参数会插入到调用新函数时传入的参数的前面。 1234567891011function foo()&#123; console.log(this)&#125;var obj = &#123;name:&#x27;john&#x27;&#125;// 需求:调用foo时，总是绑定到obj对象身上(不希望obj对象身上有函数)// 在 bind() 被调用时，这个新函数的 this 被指定为 bind() 的第一个参数，而其余参数将作为新函数的参数，供调用时进行使用 var bar = foo.bind(obj);bar()console.log(foo) 经典案例： 12345678910111213141516171819202122const module = &#123; x: 42, getX: function () &#123; console.log(&#x27;111&#x27;) return this.x; &#125;,&#125;;/** * unboundGetX 没有绑定到 module，所以 this 指向全局对象，导致返回 undefined。 * boundGetX 被绑定到 module，所以 this 指向 module，返回 42。 * */const unboundGetX = module.getX;// 全局下调用unboundGetX是this会指向全局对象windows nodejs中指向global 全局中无x，输出undefinedconsole.log(unboundGetX()); // The function gets invoked at the global scope// Expected output: undefined// bind 方法创建了一个新的函数，该函数的 this 永远指向 module。const boundGetX = unboundGetX.bind(module);console.log(boundGetX());// Expected output: 42 4.4 call()、apply()、bind()的区别及用法简单用法：都是用来改变this的指向 call、apply的一个区别： 相同点：都是调用一个对象的一个方法，用另一个对象替换当前对象（功能相同） 不同点：参数格式不同 call()的第一个参数是this要指向的对象，后面传入的是参数列表，参数可以是任意类型，当第一个参数为null、undefined的时候，默认指向window；apply()：第一个参数是this要指向的对象，第二个参数是数组[]call、bind的一个区别： 相同点: 都是用来改变this的指向 不同点：call改变this的指向后会再执行函数，bind改变this的指向后不会再执行函数，返回一个绑定新this的函数【React有用到】 用法：call函数 用来判断数据类型！ 延伸–判断数据类型的方式有哪几种？ 在判断数据类形式使用typeof，一般不是太准确的，我们可以使用Object.prototype.toString.call()方法来判断一个数据的数据类型 利用call()翻转字符串 用法：apply函数 进行求和计算 4.5 扩展：函数绑定的新姿势 ——ES7 bind 运算符（::） ES7 bind 运算符是一种新的绑定语法，它使用两个冒号 (::) 表示，通常被称为 “双冒号运算符” 或者 “作用域解析运算符”。它的作用是将一个函数绑定到一个特定的上下文中。bind 运算符始终将左边的表达式作为函数的上下文（即 this），右边的表达式作为函数名，同时还会将左边表达式中的属性和方法转移到右边表达式中。 6.this绑定规则优先级7.this绑定之外的规则8.箭头函数的写法arrow function9.箭头函数的简写arrow10.箭头函数实现所有偶数平方的和11.箭头函数中的this使用12.箭头函数中this的应用【模拟网络请求】","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/categories/JavaScript/"}],"tags":[],"keywords":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/categories/JavaScript/"}]},{"title":"promise的网络请求库，作用于node.js 和浏览器中【REVIEW】","slug":"Axios","date":"2024-06-21T14:00:41.000Z","updated":"2024-07-22T12:50:05.047Z","comments":true,"path":"2024/06/21/Axios/","permalink":"http://example.com/2024/06/21/Axios/","excerpt":"","text":"1. Axioshttps://axios-http.com/https://www.bootcss.com/前置知识： promise ajax 2. json-serverhttps://github.com/typicode/json-server 3. 安装1$ npm install axios 3. 项目开始国内引入：https://www.bootcdn.cn/axios/ 4. 发送请求5. GET12345678910const btns = document.querySelectorAll(&#x27;button&#x27;)btns[0].onclick = function ()&#123; axios(&#123; method:&#x27;GET&#x27;, url:&#x27;http://localhost:3000/posts/2&#x27; &#125;).then(response =&gt;&#123; console.log(response) &#125;)&#125; 响应200 查看请求头 6. POST12345678910111213btns[1].onclick = function ()&#123; axios(&#123; method:&#x27;POST&#x27;, url:&#x27;http://localhost:3000/posts&#x27;, // 请求体 data:&#123; title:&quot;hello&quot;, views: 120 &#125; &#125;).then(response =&gt;&#123; console.log(response) &#125;)&#125; 7. PUT12345678910111213btns[2].onclick = function ()&#123; axios(&#123; method:&#x27;PUT&#x27;, url:&#x27;http://localhost:3000/posts/2&#x27;, // 请求体 data:&#123; title:&quot;WORLD&quot;, views: 1000 &#125; &#125;).then(response =&gt;&#123; console.log(response) &#125;)&#125; 8. DELETE12345678btns[3].onclick = function ()&#123; axios(&#123; method:&#x27;DELETE&#x27;, url:&#x27;http://localhost:3000/posts/1&#x27;, &#125;).then(response =&gt;&#123; console.log(response) &#125;)&#125; 9. 其他发送请求123456789axios#request(config)axios#get(url[, config])axios#delete(url[, config])axios#head(url[, config])axios#options(url[, config])axios#post(url[, data[, config]])axios#put(url[, data[, config]])axios#patch(url[, data[, config]])axios#getUri([config]) 10. 请求配置这些是创建请求时可以用的配置选项。只有 url 是必需的。如果没有指定 method，请求将默认使用 GET 方法。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161&#123; // `url` 是用于请求的服务器 URL url: &#x27;/user&#x27;, // `method` 是创建请求时使用的方法 method: &#x27;get&#x27;, // 默认值 // `baseURL` 将自动加在 `url` 前面，除非 `url` 是一个绝对 URL。 // 它可以通过设置一个 `baseURL` 便于为 axios 实例的方法传递相对 URL baseURL: &#x27;https://some-domain.com/api/&#x27;, // `transformRequest` 允许在向服务器发送前，修改请求数据 // 它只能用于 &#x27;PUT&#x27;, &#x27;POST&#x27; 和 &#x27;PATCH&#x27; 这几个请求方法 // 数组中最后一个函数必须返回一个字符串， 一个Buffer实例，ArrayBuffer，FormData，或 Stream // 你可以修改请求头。 transformRequest: [function (data, headers) &#123; // 对发送的 data 进行任意转换处理 return data; &#125;], // `transformResponse` 在传递给 then/catch 前，允许修改响应数据 transformResponse: [function (data) &#123; // 对接收的 data 进行任意转换处理 return data; &#125;], // 自定义请求头 headers: &#123;&#x27;X-Requested-With&#x27;: &#x27;XMLHttpRequest&#x27;&#125;, // `params` 是与请求一起发送的 URL 参数 // 必须是一个简单对象或 URLSearchParams 对象 params: &#123; ID: 12345 &#125;, // `paramsSerializer`是可选方法，主要用于序列化`params` // (e.g. https://www.npmjs.com/package/qs, http://api.jquery.com/jquery.param/) paramsSerializer: function (params) &#123; return Qs.stringify(params, &#123;arrayFormat: &#x27;brackets&#x27;&#125;) &#125;, // `data` 是作为请求体被发送的数据 // 仅适用 &#x27;PUT&#x27;, &#x27;POST&#x27;, &#x27;DELETE 和 &#x27;PATCH&#x27; 请求方法 // 在没有设置 `transformRequest` 时，则必须是以下类型之一: // - string, plain object, ArrayBuffer, ArrayBufferView, URLSearchParams // - 浏览器专属: FormData, File, Blob // - Node 专属: Stream, Buffer data: &#123; firstName: &#x27;Fred&#x27; &#125;, // 发送请求体数据的可选语法 // 请求方式 post // 只有 value 会被发送，key 则不会 data: &#x27;Country=Brasil&amp;City=Belo Horizonte&#x27;, // `timeout` 指定请求超时的毫秒数。 // 如果请求时间超过 `timeout` 的值，则请求会被中断 timeout: 1000, // 默认值是 `0` (永不超时) // `withCredentials` 表示跨域请求时是否需要使用凭证 withCredentials: false, // default // `adapter` 允许自定义处理请求，这使测试更加容易。 // 返回一个 promise 并提供一个有效的响应 （参见 lib/adapters/README.md）。 adapter: function (config) &#123; /* ... */ &#125;, // `auth` HTTP Basic Auth auth: &#123; username: &#x27;janedoe&#x27;, password: &#x27;s00pers3cret&#x27; &#125;, // `responseType` 表示浏览器将要响应的数据类型 // 选项包括: &#x27;arraybuffer&#x27;, &#x27;document&#x27;, &#x27;json&#x27;, &#x27;text&#x27;, &#x27;stream&#x27; // 浏览器专属：&#x27;blob&#x27; responseType: &#x27;json&#x27;, // 默认值 // `responseEncoding` 表示用于解码响应的编码 (Node.js 专属) // 注意：忽略 `responseType` 的值为 &#x27;stream&#x27;，或者是客户端请求 // Note: Ignored for `responseType` of &#x27;stream&#x27; or client-side requests responseEncoding: &#x27;utf8&#x27;, // 默认值 // `xsrfCookieName` 是 xsrf token 的值，被用作 cookie 的名称 xsrfCookieName: &#x27;XSRF-TOKEN&#x27;, // 默认值 // `xsrfHeaderName` 是带有 xsrf token 值的http 请求头名称 xsrfHeaderName: &#x27;X-XSRF-TOKEN&#x27;, // 默认值 // `onUploadProgress` 允许为上传处理进度事件 // 浏览器专属 onUploadProgress: function (progressEvent) &#123; // 处理原生进度事件 &#125;, // `onDownloadProgress` 允许为下载处理进度事件 // 浏览器专属 onDownloadProgress: function (progressEvent) &#123; // 处理原生进度事件 &#125;, // `maxContentLength` 定义了node.js中允许的HTTP响应内容的最大字节数 maxContentLength: 2000, // `maxBodyLength`（仅Node）定义允许的http请求内容的最大字节数 maxBodyLength: 2000, // `validateStatus` 定义了对于给定的 HTTP状态码是 resolve 还是 reject promise。 // 如果 `validateStatus` 返回 `true` (或者设置为 `null` 或 `undefined`)， // 则promise 将会 resolved，否则是 rejected。 validateStatus: function (status) &#123; return status &gt;= 200 &amp;&amp; status &lt; 300; // 默认值 &#125;, // `maxRedirects` 定义了在node.js中要遵循的最大重定向数。 // 如果设置为0，则不会进行重定向 maxRedirects: 5, // 默认值 // `socketPath` 定义了在node.js中使用的UNIX套接字。 // e.g. &#x27;/var/run/docker.sock&#x27; 发送请求到 docker 守护进程。 // 只能指定 `socketPath` 或 `proxy` 。 // 若都指定，这使用 `socketPath` 。 socketPath: null, // default // `httpAgent` and `httpsAgent` define a custom agent to be used when performing http // and https requests, respectively, in node.js. This allows options to be added like // `keepAlive` that are not enabled by default. httpAgent: new http.Agent(&#123; keepAlive: true &#125;), httpsAgent: new https.Agent(&#123; keepAlive: true &#125;), // `proxy` 定义了代理服务器的主机名，端口和协议。 // 您可以使用常规的`http_proxy` 和 `https_proxy` 环境变量。 // 使用 `false` 可以禁用代理功能，同时环境变量也会被忽略。 // `auth`表示应使用HTTP Basic auth连接到代理，并且提供凭据。 // 这将设置一个 `Proxy-Authorization` 请求头，它会覆盖 `headers` 中已存在的自定义 `Proxy-Authorization` 请求头。 // 如果代理服务器使用 HTTPS，则必须设置 protocol 为`https` proxy: &#123; protocol: &#x27;https&#x27;, host: &#x27;127.0.0.1&#x27;, port: 9000, auth: &#123; username: &#x27;mikeymike&#x27;, password: &#x27;rapunz3l&#x27; &#125; &#125;, // see https://axios-http.com/zh/docs/cancellation cancelToken: new CancelToken(function (cancel) &#123; &#125;), // `decompress` indicates whether or not the response body should be decompressed // automatically. If set to `true` will also remove the &#x27;content-encoding&#x27; header // from the responses objects of all decompressed responses // - Node only (XHR cannot turn off decompression) decompress: true // 默认值&#125; 11. axios响应信息 config 配置对象 data 响应体 header 响应头信息 request 原生的ajax对象 status statusText 1234567891011121314151617181920212223&#123; // `data` 由服务器提供的响应 data: &#123;&#125;, // `status` 来自服务器响应的 HTTP 状态码 status: 200, // `statusText` 来自服务器响应的 HTTP 状态信息 statusText: &#x27;OK&#x27;, // `headers` 是服务器响应头 // 所有的 header 名称都是小写，而且可以使用方括号语法访问 // 例如: `response.headers[&#x27;content-type&#x27;]` headers: &#123;&#125;, // `config` 是 `axios` 请求的配置信息 config: &#123;&#125;, // `request` 是生成此响应的请求 // 在node.js中它是最后一个ClientRequest实例 (in redirects)， // 在浏览器中则是 XMLHttpRequest 实例 request: &#123;&#125;&#125; 12. axios默认配置123456789101112131415161718192021222324252627282930313233343536373839&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;axios基本使用&lt;/title&gt; &lt;link crossorigin=&quot;anonymous&quot; href=&quot;https://cdn.bootcss.com/twitter-bootstrap/3.3.7/css/bootstrap.min.css&quot; rel=&quot;stylesheet&quot;&gt; &lt;script src=&quot;https://cdn.bootcdn.net/ajax/libs/axios/0.21.1/axios.min.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;container&quot;&gt; &lt;h2 class=&quot;page-header&quot;&gt;基本使用&lt;/h2&gt; &lt;button class=&quot;btn btn-primary&quot;&gt; 发送GET请求 &lt;/button&gt; &lt;button class=&quot;btn btn-warning&quot; &gt; 发送POST请求 &lt;/button&gt; &lt;button class=&quot;btn btn-success&quot;&gt; 发送 PUT 请求 &lt;/button&gt; &lt;button class=&quot;btn btn-danger&quot;&gt; 发送 DELETE 请求 &lt;/button&gt; &lt;/div&gt; &lt;script&gt; //获取按钮 const btns = document.querySelectorAll(&#x27;button&#x27;); //默认配置 axios.defaults.method = &#x27;GET&#x27;;//设置默认的请求类型为 GET axios.defaults.baseURL = &#x27;http://localhost:3000&#x27;;//设置基础 URL axios.defaults.params = &#123;id:100&#125;; axios.defaults.timeout = 3000;// btns[0].onclick = function()&#123; axios(&#123; url: &#x27;/posts&#x27; &#125;).then(response =&gt; &#123; console.log(response); &#125;) &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"http网络","slug":"http网络","permalink":"http://example.com/categories/http%E7%BD%91%E7%BB%9C/"}],"tags":[],"keywords":[{"name":"http网络","slug":"http网络","permalink":"http://example.com/categories/http%E7%BD%91%E7%BB%9C/"}]},{"title":"关于Node的基本认识【BASIC】","slug":"Node.js【入门级】","date":"2024-05-20T14:00:41.000Z","updated":"2024-07-22T11:38:13.728Z","comments":true,"path":"2024/05/20/Node.js【入门级】/","permalink":"http://example.com/2024/05/20/Node.js%E3%80%90%E5%85%A5%E9%97%A8%E7%BA%A7%E3%80%91/","excerpt":"","text":"1可以脱离浏览器来执行js代码,没有DOM和BOM对象,针对后端可以编写接口，提供网页资源，前端可以集成各种工具（承上启下） node1.Buffer 2.Buffer相关操作 123456let buf = Buffer.alloc(10)console.log(buf);let buf_2 = Buffer.allocUnsafe(100)console.log(buf_2);let buf_3 = Buffer.from(&#x27;hello&#x27;)console.log(buf_3); 3.fs模块-读写模块【回顾一下liunx操作系统】【增删改查操作】 1与本机文件系统进行交互的，方法和属性 4.fs异步和同步 5.fs文件追加操作 6.文件写入的场景-【做持久化】 7.文件读取 8.写一个创建文件的脚本9.fs流式写入 10.exports对象12由于module.exports 单词写起来比较复杂，为了简化向外共享成员的代码，Node 提供了exports 对象。默认情况下，exports和module.exports 指向同一个对象。最终共享的结果，还是以module.exports指向的对象为准。时刻谨记，require()模块时，得到的永远是module.exports指向的对象: 11.计算机组成 12.模块化12345-require的使用-模块化的好处-&gt;无法共享成员-module对象，每个.js都自定义模块中都有一个module对象-exports 自定义模块中，可以使用exports将模块中的成员共享出去，给外界使用 在自定义模块中，默认情况下，module.export = &#123;&#125;使用require()方法导入模块时，导入的结果，永远以module.exports指向的对象为准。 13.模块化初体验 14.模块暴露数据 15.导入（引入）模块导入 js 和 json文件时 可以省略后缀 16.导入模块的基本流程 17.commonJS规范 18.包管理工具【哆啦A梦】 19.npm 20.npm基本使用20.1初始化 123456789101112&#123; &quot;name&quot;: &quot;test01&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;&quot;, &quot;main&quot;: &quot;index.js&quot;, &quot;scripts&quot;: &#123; &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot; &#125;, &quot;author&quot;: &quot;c&quot;, &quot;license&quot;: &quot;ISC&quot;&#125; 20.2如何搜索&#x2F;下载npm包 npmjs.com 20.3require导入包的基本流程 20.4开发依赖和生产依赖https://juejin.cn/post/7135795969370619918 20.5npm全局安装 20.6修改windows执行策略 21.环境变量path 20.1 npm安装包的所有依赖 22.安装指定版本的包 23.配置命令别名 24.cnpm 25.配置淘宝镜像 26.yarn 27.npm和yarn的使用 28.管理发布包 29.更新和删除 30.扩展 31.nvm 32.常用命令 33.expressJSExpress是一个流行的Node.js Web应用程序框架，用于构建服务器端应用程序。它提供了一组简洁而灵活的工具和中间件，使开发者可以轻松地构建RESTful API和Web应用。Express具有路由、请求和响应处理、中间件等功能，可以帮助开发者管理HTTP请求和构建服务器端逻辑。通过Express，可以搭建一个响应请求的服务器，处理前端发起的HTTP请求并返回相应的数据或页面。 34.简单应用35.路由 方法 路径 回调12345678910111213141516171819202122232425const express = require(&#x27;express&#x27;)const app = express()// 路由app.get(&#x27;/home&#x27;,(req,res) =&gt;&#123; res.end(&#x27;Welcome to the Home page&#x27;)&#125; )app.get(&#x27;/&#x27;,(req,res) =&gt;&#123; res.end(&#x27;Welcome to the Home page with instructions for creating&#x27;)&#125;)app.post(&#x27;/login&#x27;,(req,res) =&gt;&#123; res.end(&#x27;Welcome to the Login page&#x27;)&#125;)app.get(&#x27;*&#x27;,(req,res) =&gt;&#123; res.end(&#x27;404 Not Found &#x27;)&#125;)app.listen(3000,()=&gt;&#123; console.log(&#x27;listening on http://localhost&#x27;)&#125;) 36.获取请求参数 37.获取路由参数","categories":[{"name":"node","slug":"node","permalink":"http://example.com/categories/node/"}],"tags":[],"keywords":[{"name":"node","slug":"node","permalink":"http://example.com/categories/node/"}]},{"title":"浏览器【WebKit内核】渲染原理【QUESTION】","slug":"浏览器与JS的原理","date":"2024-04-20T14:00:41.000Z","updated":"2024-07-22T02:46:39.761Z","comments":true,"path":"2024/04/20/浏览器与JS的原理/","permalink":"http://example.com/2024/04/20/%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%8EJS%E7%9A%84%E5%8E%9F%E7%90%86/","excerpt":"","text":"1.浏览器输入一个网址（域名之后）,浏览器会呈现一个新的页面，中间的过程是怎么实现的？输入一个网址之后，首先DNS服务器会解析这个域名，将这个域名解析成IP地址，通过IP地址会访问到对应的服务器从该服务器中去请求资源，服务器首先会给浏览器返回index.html的静态资源，那么浏览器就可以通过一行行的从上到下的进行解析index.html文件【浏览器的内核：例如WebKit】，从而将HTML解析成一棵DOM树，如果中间有解析到link链接，就会去下载解析链接的内容，如css文件，但是这期间浏览器会继续向下进行解析，不会停留或者阻塞dom树的进行；下载完css文件后，会对css进行解析，生成cssom,称为css对象模型；通俗将也是一棵规则树。那么通过dom和cssom两棵树结合起来会生成一棵新的render tree。最后浏览器对这颗新的render tree的每个节点进行布局【排版引擎】和绘制到屏幕成，最终形成一个新个页面。 2.浏览器是如何解析服务器返回的静态资源的？然后呈现出页面的?https://web.dev/articles/howbrowserswork?hl=zh-cn html----&gt;dom css-----&gt;cssom 结合构建--------&gt;render tree 布局 ----- 绘制 ----- 呈现 3.什么是回流和重绘？第一次确定页面节点的大小和位置称为布局，当第二次重新计算页面节点的大小和位置成为回流 第一次渲染内容称为绘制，第二次重新渲染称为重绘 4.什么情况下会引起回流？什么情况下会引起重绘？1.DOM结构发生了改变 颜色、背景、样式等发生了改变 2.页面布局发生了改变 3.窗口resize发生了改变 5.怎么避免回流？样式尽量一次性修改 尽量频繁的操作DOM","categories":[{"name":"浏览器","slug":"浏览器","permalink":"http://example.com/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"}],"tags":[],"keywords":[{"name":"浏览器","slug":"浏览器","permalink":"http://example.com/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"}]},{"title":"一文知TypeScript的核心","slug":"颠覆认知的『TypeScript』【TS深度学习】","date":"2024-03-20T14:00:41.000Z","updated":"2024-07-21T04:36:07.563Z","comments":true,"path":"2024/03/20/颠覆认知的『TypeScript』【TS深度学习】/","permalink":"http://example.com/2024/03/20/%E9%A2%A0%E8%A6%86%E8%AE%A4%E7%9F%A5%E7%9A%84%E3%80%8ETypeScript%E3%80%8F%E3%80%90TS%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%91/","excerpt":"","text":"TypeSript【官网】【READBOOK】https://www.bookstack.cn/read/wangdoc-typescript-tutorial/docs-d.ts.md ts是js的一个超集，解决js类型支持js: 动态类型ts:静态类型 代码执行的顺序是先编译在执行 发现错误更早 1.为什么要添加类型支持？ 2.优势有什么？ 3.全局安装npm i -g typescripttsc -v 4.简化运行ts的步骤 5.typescript常用类型 类型检查机制 5.1 类型注解 5.2 常用基础类型 5.3 原始类型 6.数组类型 7.类型别名 type关键字 123456// 类型别名type CustomArray = (number|string)[]let arr1:CustomArray = [1,2,&#x27;a&#x27;,3]let arr2:CustomArray = [1,4,&#x27;a&#x27;,3]console.log(arr1);console.log(arr2); 8.函数类型 9.可选参数 10.对象类型对象的类型其实就是在描述对象的结构 11.对象中的可选属性 12.接口【复用】 1234567891011121314151617181920212223// 接口interface IPerson&#123; name:string age:number sayhi():void&#125;let person_3:IPerson =&#123; name:&#x27;JACL&#x27;, age:11, sayhi()&#123;&#125;&#125;let person_4:IPerson =&#123; name:&#x27;JAC33L&#x27;, age:33, sayhi()&#123;&#125;&#125;console.log(person_3);console.log(person_4); 13.接口和类型别名 12345type num = number | stringlet a:num = 1let b:num = &#x27;asf&#x27;console.log(a);console.log(b); 14.接口继承复用 15.元组 16.类型推论 17.类型断言 18.字面量类型 19.枚举类型 20.字符串枚举 21.枚举特点 22.any类型 23.ypeof 24.TS高级类型24.1 class 25.类的实例方法 26.类的继承 27.类成员可见性 28.类型兼容性 29.对象兼容性 30.接口兼容性 31.函数兼容性 32.类型兼容性 33.交叉类型 34.交叉类型(&amp;)和接口继承(extends)的区别 35.泛型 36.简化调用泛型函数 37.泛型循环 38.添加约束 39.泛型的类型变量 40.泛型接口41.JS中的数组就是TS中的一个泛型接口 42.class配合泛型来使用 43.泛型工具类型43.1 partial 43.2 readonly 43.3 pick 43.4 record 44.索引签名类型 45.映射类型45.1 基于旧类型进行创建 45.2 基于对象创建 45.3 引查询类型 45.4 同时查询多个索引的类型 46.d.ts 类型声明文件 47.TS中的两种文件类型 48.类型声明文件的使用说明 49.使用已有的类型声明文件49.1 内置api 49.2 第三方库的类型声明 49.3 definitelyTyped 49.4 创建自己的声明文件 49.5 项目内共享类型 49.6 为已有js文件提供类型声明 50.【webpack】搭建一个基本的webpack4.x项目51.React支持TS","categories":[{"name":"TypeScript","slug":"TypeScript","permalink":"http://example.com/categories/TypeScript/"}],"tags":[],"keywords":[{"name":"TypeScript","slug":"TypeScript","permalink":"http://example.com/categories/TypeScript/"}]},{"title":"面试题【Record】第一回","slug":"面试题【Record】第一回","date":"2024-02-20T14:00:41.000Z","updated":"2024-07-22T02:40:51.345Z","comments":true,"path":"2024/02/20/面试题【Record】第一回/","permalink":"http://example.com/2024/02/20/%E9%9D%A2%E8%AF%95%E9%A2%98%E3%80%90Record%E3%80%91%E7%AC%AC%E4%B8%80%E5%9B%9E/","excerpt":"","text":"如何判断一个对象为空？为什么data是一个函数?v-if与v-show的区别？用法与本质上的区别v-for中的key是什么作用? diff算法的实现原理虚拟DOM的作用？真实DOM &amp; 通过移动原生控件在移动端显示出来 &amp; 桌面端的一些控件 &amp; VR设备 –做跨平台computed 和 methods的区别？展开运算符的用法？获取Vue创建的代理的原始对象？toRawwatch的基本用法，以及侦听选项？deep immediate vue事件绑定如何传递参数?如何传递event参数?v-for中的key有什么作用?什么是虚拟DOM?什么是计算属性?和method有什么区别?如何在Vue中侦听一个数据的改变?v-model的原理? 什么是双向绑定?v-model的本质是什么?如何手动实现v-model?v-moder加上lazy、number、trim修饰符有什么作用？什么是组件化开发?有什么作用?什么是Vue CLl，如何使用它创建Vue项目? 脚手架创建项目的流程？Vue中注册全局组件和局部组件有什么区别?","categories":[{"name":"Record","slug":"Record","permalink":"http://example.com/categories/Record/"}],"tags":[],"keywords":[{"name":"Record","slug":"Record","permalink":"http://example.com/categories/Record/"}]}]}